<!DOCTYPE html>
<html lang="en">
<head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
<meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">




    <meta name="keywords" content=""/>



    <meta name="description" content="Kumiko77"/>


<meta name="Robots" content="all">


    <title>Kumiko77</title>


<link rel="icon" href="/images/favicon.ico">

<link rel="stylesheet" href="/css/font-awesome.min.css">


<link rel="stylesheet" href="/css/atom-one-dark.css">


<link rel="stylesheet" href="/css/style.css">


<script src="/js/highlight.min.js"></script>

<meta name="generator" content="Hexo 4.2.1"></head>
<body>
    <div class="main-container">
        <header class="header">
    <div class="global-width">
        <nav class="nav-box">
            
                <a class="nav-item" href="/"
                
                >Home</a>
            
                <a class="nav-item" href="/resume"
                
                >Resume</a>
            
                <a class="nav-item" href="/mood"
                
                   target="_blank"
                
                >Mood</a>
            
                <a class="nav-item" href="/amusement/tetris"
                
                   target="_blank"
                
                >Amusement</a>
            
                <a class="nav-item" href="/about"
                
                >About</a>
            
        </nav>
    </div>
</header>

        <section class="content global-width">
            <div class="main">
                
    
        <article class="box post post-item">
            <div class="post-title"><a href="/2020/10/28/%E5%85%B3%E4%BA%8Ejs%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE/">关于js原型和原型链</a></div>
            <div class="post-meta">
                
                <i class="fa fa-calendar"></i> <time>2020-10-28</time>
                <span class="dotted">|</span>
                <i class="fa fa-user"></i> 
            </div>

            <div class="post-excerpt">
                <a href="/2020/10/28/%E5%85%B3%E4%BA%8Ejs%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE/">
                    <p>
                        
                            123456function Person() &#123;  &#x2F;&#x2F;...&#125;var person &#x3D; new Person();person.name &#x3D; &#39;Tom&#39;;console.log(person.name) &#x2F;&#x2F; Tom
这里的Person就是一个构造函数，我们用new创建了一个实例对象person
1. prototype
每一个函数都有一个prototype属性
每一个JavaScript对象（null除外）在创建的时候都会关联另外一个对象，这个对象就是我们所说的原型，每一个对象都会从其原型上“继承”属性12345678function Person() &#123;  &#x2F;&#x2F;...&#125;Person.prototype.name &#x3D; &#39;Tom&#39;;var person1 &#x3D; new Person();var person2 &#x3D; new Person();console.log(person1.name) &#x2F;&#x2F; Tomconsole.log(person2.name) &#x2F;&#x2F; Tom




2. proto每一个JavaScript对象(null除外)都具有的一个属性，叫proto，这个属性会指向该对象的原型
12345function Person() &#123;&#x2F;&#x2F;...&#125;var person &#x3D; new Person();console.log(person.__proto__ &#x3D;&#x3D;&#x3D; Person.prototype); &#x2F;&#x2F; true


3. constructor每个原型都有一个constructor属性，指向关联的构造函数

12345678910function Person() &#123;&#x2F;&#x2F;...&#125;var person &#x3D; new Person();console.log(person.__proto__ &#x3D;&#x3D; Person.prototype) &#x2F;&#x2F; trueconsole.log(Person.prototype.constructor &#x3D;&#x3D; Person) &#x2F;&#x2F; true&#x2F;&#x2F; ES6console.log(Object.getPrototypeOf(person) &#x3D;&#x3D;&#x3D; Person.prototype) &#x2F;&#x2F; true

3. 实例与原型12345678910111213function Person() &#123;&#x2F;&#x2F;...&#125;Person.prototype.name &#x3D; &#39;Kevin&#39;;var person &#x3D; new Person();person.name &#x3D; &#39;Daisy&#39;;console.log(person.name) &#x2F;&#x2F; Daisydelete person.name;console.log(person.name) &#x2F;&#x2F; Kevin
在这个例子中，我们给实例对象 person 添加了 name 属性，当我们打印 person.name 的时候，结果自然为 Daisy。
但是当我们删除了 person 的 name 属性时，读取 person.name，从 person对象中找不到name属性就会从person的原型也就是person.proto，也就是 Person.prototype中查找
4. 原型链1console.log(Object.prototype.__proto__ &#x3D;&#x3D;&#x3D; null) &#x2F;&#x2F; true



                        
                    </p>
                </a>
            </div>

            
        </article>
    

    
        <article class="box post post-item">
            <div class="post-title"><a href="/2020/10/26/Vuex%E6%A8%A1%E5%9D%97%E5%8C%96/">Vuex模块化</a></div>
            <div class="post-meta">
                
                <i class="fa fa-calendar"></i> <time>2020-10-26</time>
                <span class="dotted">|</span>
                <i class="fa fa-user"></i> 
            </div>

            <div class="post-excerpt">
                <a href="/2020/10/26/Vuex%E6%A8%A1%E5%9D%97%E5%8C%96/">
                    <p>
                        
                            1. Vuex模块化（module）模块这部分正如其名，当所有状态集中在一个对象中时，会变的相当臃肿，这个时候就需要对其进行模块化管理。比如我在store里面定义了两个模块
12345678910111213141516171819const moduleA &#x3D; &#123;  state: &#123;    name: &#39;lee&#39;,    age: 23,  &#125;,  mutations: &#123;&#125;,  getters: &#123;&#125;,  actions: &#123;&#125;&#125;;const moduleB &#x3D; &#123;  state: &#123;    name: &#39;wang&#39;,    age: 22  &#125;,  mutations: &#123;&#125;,  getters: &#123;&#125;,  actions: &#123;&#125;&#125;
然后接着在store里声明模块
123456789export default new Vuex.Store(&#123;  modules: &#123;    ma: moduleA,    mb: moduleB  &#125;,  state: &#123;    ........... &#x2F;&#x2F; 其他状态  &#125;&#125;);
这样一来，如果我们想要在组件里面访问其他模块的状态，可以这样，比如这里我想调用B模块里的状态
12345computed: &#123;  msg() &#123;    return this.$store.mb; &#x2F;&#x2F; 这里返回的是：&#123;name: &#39;wang&#39;, age: 22&#125;  &#125;&#125;
复制代码关于模块内部的局部状态，这里跟普通的store用法没有多大的区别，主要区别以下外部传进来的状态，比如对于模块内部的 action，局部状态通过 context.state 暴露出来，根节点状态则为 context.rootState，这里截取官方代码
12345678910const moduleA &#x3D; &#123;  &#x2F;&#x2F; ...  actions: &#123;    incrementIfOddOnRootSum (&#123; state, commit, rootState &#125;) &#123;      if ((state.count + rootState.count) % 2 &#x3D;&#x3D;&#x3D; 1) &#123;        commit(&#39;increment&#39;)      &#125;    &#125;  &#125;&#125;
对于模块内部的 getter，根节点状态会作为第三个参数暴露出来：
12345678const moduleA &#x3D; &#123;  &#x2F;&#x2F; ...  getters: &#123;    sumWithRootCount (state, getters, rootState) &#123;      return state.count + rootState.count    &#125;  &#125;&#125;
复制代码那么对于getters、mutations、actions里面的方法我们像基本的store那样调用就可以了，不存在作用域限制，还是贴代码栗子吧，下面是我在store.js里面定义的模块B：
123456789101112131415161718const moduleB &#x3D; &#123;  state: &#123;    name: &#39;wang&#39;,    age: 22,    desc: &#39;nope&#39;  &#125;,  mutations: &#123;    modifyDesc(state, payload) &#123;      state.desc &#x3D; payload.newMsg;    &#125;  &#125;,  getters: &#123;  &#125;,  actions: &#123;  &#125;&#125;
复制代码在组件里面，我定义了以下内容：
1234567891011121314151617181920212223242526272829303132&lt;template&gt;  &lt;div&gt;    &lt;h2&gt;7、module使用示例&lt;&#x2F;h2&gt;    &lt;div&gt;      &lt;p&gt;名字：&#123;&#123; name &#125;&#125;&lt;&#x2F;p&gt;      &lt;p&gt;描述：&#123;&#123; desc &#125;&#125;&lt;&#x2F;p&gt;      &lt;button @click&#x3D;&quot;handleClick&quot;&gt;修改描述&lt;&#x2F;button&gt;    &lt;&#x2F;div&gt;  &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;export default &#123;  data() &#123;    return &#123;      name: this.$store.state.mb.name,      &#x2F;&#x2F; desc: this.$store.state.mb.desc 注意这个如果涉及到要在store里面会被改变的状态，一定要写在      &#x2F;&#x2F; computed属性里面，不然不能及时反馈到视图上    &#125;  &#125;,  computed: &#123;    desc() &#123;      return this.$store.state.mb.desc;    &#125;  &#125;,  methods: &#123;    handleClick() &#123;      this.$store.commit(&#39;modifyDesc&#39;, &#123;newMsg: &#39;lao wang is beautiful!&#39;&#125;);    &#125;  &#125;,&#125;&lt;&#x2F;script&gt;
这样，就可以调用mutation里面的方法了，getters和actions同理
2.命名空间模块默认情况下，mutations、actions、getters这些都是注册在全局上面的，你可以直接调用，如果希望你的模块具有更高的封装度和复用性，你可以通过添加 namespaced: true 的方式使其成为带命名空间的模块。当模块被注册后，它的所有 getter、action 及 mutation 都会自动根据模块注册的路径调整命名。首先我新建一个js文件用来声明模块C：
1234567891011121314151617181920212223export const moduleC &#x3D; &#123;  namespaced: true,  state: &#123;    name: &#39;moduleC&#39;,    desc: &#39;这是模块C，用来测试命名空间的！&#39;,    list: [1, 2, 3, 4]  &#125;,  getters: &#123;    filterList(state) &#123;      return state.list.filter((item, index, arrSelf) &#x3D;&gt; &#123;        return item % 2 !&#x3D;&#x3D; 0;      &#125;);    &#125;  &#125;,  mutations: &#123;    modifyName(state, payload) &#123;      state.name &#x3D; payload.newName;    &#125;  &#125;,  actions: &#123;      &#125;&#125;
复制代码然后在store.js里面引入
1234567import &#123; moduleC &#125; from &#39;.&#x2F;module_c.js&#39;;export default new Vuex.Store(&#123;  modules: &#123;    mc: moduleC  &#125;,&#125;);
要想这个模块成为带有命名空间的模块，在上面声明属性namespaced: true就可以了，那么里面的mutations、getters和actions里面的方法的调用就要多走一层路径，比如我在组件里面去调用mutations里面的方法（getters和actions同理）
1234567891011methods: &#123;  modify() &#123;    &#x2F;&#x2F; this.$store.commit(&#39;mc&#x2F;modifyName&#39;, &#123;    &#x2F;&#x2F;   newName: &#39;命名空间模块C&#39;    &#x2F;&#x2F; &#125;)    this.$store.commit(&#123;      type: &#39;mc&#x2F;modifyName&#39;,      newName: &#39;命名空间模块C&#39;    &#125;)  &#125;&#125;
复制代码当然模块里面再嵌套模块也可以，路径要不要多走一层主要看你的namespaced: true有没有声明，这里贴一下官方的代码：
12345678910111213141516171819202122232425262728293031323334353637383940const store &#x3D; new Vuex.Store(&#123;  modules: &#123;    account: &#123;      namespaced: true,      &#x2F;&#x2F; 模块内容（module assets）      state: &#123; ... &#125;, &#x2F;&#x2F; 模块内的状态已经是嵌套的了，使用 &#96;namespaced&#96; 属性不会对其产生影响      getters: &#123;        isAdmin () &#123; ... &#125; &#x2F;&#x2F; -&gt; getters[&#39;account&#x2F;isAdmin&#39;]      &#125;,      actions: &#123;        login () &#123; ... &#125; &#x2F;&#x2F; -&gt; dispatch(&#39;account&#x2F;login&#39;)      &#125;,      mutations: &#123;        login () &#123; ... &#125; &#x2F;&#x2F; -&gt; commit(&#39;account&#x2F;login&#39;)      &#125;,      &#x2F;&#x2F; 嵌套模块      modules: &#123;        &#x2F;&#x2F; 继承父模块的命名空间        myPage: &#123;          state: &#123; ... &#125;,          getters: &#123;            profile () &#123; ... &#125; &#x2F;&#x2F; -&gt; getters[&#39;account&#x2F;profile&#39;]          &#125;        &#125;,        &#x2F;&#x2F; 进一步嵌套命名空间        posts: &#123;          namespaced: true,          state: &#123; ... &#125;,          getters: &#123;            popular () &#123; ... &#125; &#x2F;&#x2F; -&gt; getters[&#39;account&#x2F;posts&#x2F;popular&#39;]          &#125;        &#125;      &#125;    &#125;  &#125;&#125;)
在带命名空间的模块内访问全局内容如果想要在模块内部的getters、mutations和actions里面访问到全局的内容，这儿Vuex已经封装好了，你只需要多传几个参数即可
12345678910111213141516171819202122232425262728293031modules: &#123;  foo: &#123;    namespaced: true,    getters: &#123;      &#x2F;&#x2F; 在这个模块的 getter 中，&#96;getters&#96; 被局部化了      &#x2F;&#x2F; 你可以使用 getter 的第四个参数来调用 &#96;rootGetters&#96;      someGetter (state, getters, rootState, rootGetters) &#123;        getters.someOtherGetter &#x2F;&#x2F; -&gt; &#39;foo&#x2F;someOtherGetter&#39;        rootGetters.someOtherGetter &#x2F;&#x2F; -&gt; &#39;someOtherGetter&#39;      &#125;,      someOtherGetter: state &#x3D;&gt; &#123; ... &#125;    &#125;,    actions: &#123;      &#x2F;&#x2F; 在这个模块中， dispatch 和 commit 也被局部化了      &#x2F;&#x2F; 他们可以接受 &#96;root&#96; 属性以访问根 dispatch 或 commit      someAction (&#123; dispatch, commit, getters, rootGetters &#125;) &#123;        getters.someGetter &#x2F;&#x2F; -&gt; &#39;foo&#x2F;someGetter&#39;        rootGetters.someGetter &#x2F;&#x2F; -&gt; &#39;someGetter&#39;        dispatch(&#39;someOtherAction&#39;) &#x2F;&#x2F; -&gt; &#39;foo&#x2F;someOtherAction&#39;        dispatch(&#39;someOtherAction&#39;, null, &#123; root: true &#125;) &#x2F;&#x2F; -&gt; &#39;someOtherAction&#39;        commit(&#39;someMutation&#39;) &#x2F;&#x2F; -&gt; &#39;foo&#x2F;someMutation&#39;        commit(&#39;someMutation&#39;, null, &#123; root: true &#125;) &#x2F;&#x2F; -&gt; &#39;someMutation&#39;      &#125;,      someOtherAction (ctx, payload) &#123; ... &#125;    &#125;  &#125;&#125;
复制代码在模块里面使用辅助函数mapState、mapGetters、mapMutations和mapActions由于存在命名空间，在组件里面采用上面的写法会出现问题，这里要想使用辅助函数来映射模块里面的东西需要指定空间名称来告诉辅助函数应该去哪儿找这些。这儿我以上面我的C模块为例，首先对于mapSatate函数可以这样玩，我在全局的modules里面声明了mc，那我的空间名称就是mc
123computed: &#123;  ...mapState(&#39;mc&#39;, [&#39;name&#39;, &#39;desc&#39;]) &#x2F;&#x2F; 这里模块里面要使用辅助函数的话要多传一个参数才行&#125;
复制代码然后在模版里面写name，desc即可，或者可以这样
12345678910computed: &#123;  ...mapState(&#39;mc&#39;, &#123;    name(state) &#123;      return state.name;    &#125;,    desc(state) &#123;      return state.desc;    &#125;  &#125;)&#125;,
复制代码对于actions、mutations和getters方式类似，主要是要指定空间名称

                        
                    </p>
                </a>
            </div>

            
        </article>
    

    
        <article class="box post post-item">
            <div class="post-title"><a href="/2020/10/26/Vuex%E5%9F%BA%E7%A1%80/">Vuex基础</a></div>
            <div class="post-meta">
                
                <i class="fa fa-calendar"></i> <time>2020-10-26</time>
                <span class="dotted">|</span>
                <i class="fa fa-user"></i> 
            </div>

            <div class="post-excerpt">
                <a href="/2020/10/26/Vuex%E5%9F%BA%E7%A1%80/">
                    <p>
                        
                            1. 关于Vuex1.1 为什么要使用Vuex我们在Vue开发过程中，难免会有一些状态要在多个组件中使用的情况，比如用户昵称、头像等其他用户信息。这些信息在多个组件中会使用到，所以我们就希望其状态一旦发现改变，其他组件也跟着变化,比如用户充值了一百元或是改变了头像，所以这个时候就需要状态管理模式来集中来管理
1.2 基本结构1234567891011121314151617181920212223import Vue from &#39;vue&#39;import Vuex from &#39;vuex&#39;Vue.use(Vuex)export default new Vuex.Store(&#123;  state: &#123;    count: 0  &#125;,  mutations: &#123;    SET_COUNT:(state) &#x3D;&gt; &#123;      state.count ++    &#125;  &#125;,  actions: &#123;    count(&#123; commit &#125;) &#123;      commit(&#39;SET_COUNT&#39;)    &#125;,  &#125;,  getters: &#123;    getCountValue: state &#x3D;&gt; state.count,  &#125;&#125;)
2. StateVuex的核心就是store仓库，这个store实例会被注入到所有子组件中，里边的state保存着我们的状态，比如我们定义一个状态count
12345export default new Vuex.Store(&#123;  state: &#123;    count: 10  &#125;&#125;)
这样我们就有一个集中管理的状态count，那其他组件如何取到这个count呢，可以计算属性来获得
12345678910export default &#123;  data() &#123;      &#125;,  computed: &#123;    count() &#123;      return this.$store.state.count;    &#125;  &#125;&#125;
2.1 mapState有的时候一个组件内要获取多个状态，使用计算属性需要调用多次，那就很烦，这里可以使用辅助函数mapState。使用mapState需要在页面中引入此方法
1import &#123; mapState &#125; from &#39;vuex&#39;;
但是使用mapState的话computed的写法会和之前有一些差别
12345678910111213141516171819202122&#x2F;&#x2F;不使用mapStatedata()&#123;  return&#123;      &#125;&#125;computed: &#123;  msg() &#123;    return this.$store.state.count;  &#125;&#125;&#x2F;&#x2F;使用mapStatecomputed: &#123;   msg() &#123;    return this.$store.state.msg;  &#125;,  &#x2F;&#x2F; 这里返回一个状态count  ...mapState([&#39;count&#39;])  &#x2F;&#x2F; 返回多个你可以这样写...mapState([&#39;count&#39;, &#39;firstName&#39;, &#39;lastName&#39;])  &#125;
3. Gettergetter就是对状态进行处理之后在提取出来的公共部分，当状态需要进行筛选这些操作时，我们就可以使用getter将数据处理之后在返回给组件使用，假设在state里定义一个数组
12345export default new Vuex.Store(&#123;  state: &#123;    list: [1, 2, 3, 4, 5, 6, 7, 8]  &#125;,&#125;);
我们想要将list数组里的数字筛选出偶数在组件中使用，那就可以把这个操作放在getter里进行
1234567891011export default new Vuex.Store(&#123;  state: &#123;    list: [1, 2, 3, 4, 5, 6, 7, 8]  &#125;,  getters: &#123;    modifyArr(state) &#123;       return state.list.filter((item, index, arr) &#x3D;&gt; &#123;        return item % 2 &#x3D;&#x3D; 0;      &#125;)    &#125;&#125;);
之后再在其他组件的computed里面去调用getter来获取想要的状态
12345computed: &#123;    list() &#123;      return this.$store.getters.modifyArr;    &#125;,&#125;
3.1 mapGettersmapGetters 辅助函数仅仅是将 store 中的 getter 映射到局部计算属性，当我们想在组件里面引入多个getter时，可以使用mapGetter
1234import &#123;mapGetters&#125; from &#39;vuex&#39;;computed: &#123;  ...mapGetter([&#39;modifyArr&#39;, &#39;getLength&#39;])&#125;
也可以为其自定义名字不一定要用getter里设置的名字
123456computed: &#123;  ...mapGetter(&#123;    arr: &#39;modifyArr&#39;,   &#x2F;&#x2F; 把 &#96;this.arr&#96; 映射为 &#96;this.$store.getters.modifyArr&#96;,下面同理    length: &#39;getLength&#39;  &#125;)&#125;
4.Mutation当我们需要改变state里的属性时，我们是不能直接在组件里对其进行修改的，我们需要借助mutation里的里的方法来对其进行修改。比如state里有一个状态count我们要对其进行计数操作
12345678state: &#123;  count: 0&#125;,mutations: &#123;  add(state) &#123;    state.count++;  &#125;&#125;,
在其他组件里我们通过method来触发mutation，这里需要使用commit
12345methods: &#123;  add() &#123;    this.$store.commit(&#39;add&#39;);  &#125;&#125;
4.1 参数传递比如我需要在计数时传递自己想要的数字
12345mutations: &#123;  add(state, num) &#123;    state.count +&#x3D; num;  &#125;&#125;
在组件中使用
12345methods: &#123;  loadAdd() &#123;    this.$store.commit(&#39;loadAdd&#39;, 100); &#x2F;&#x2F; 传递额外参数  &#125;&#125;
官方文档建议额外传参最好写成对象的方式,这样可以传递多个字段，代码看起来也会更清晰
123this.$store.commit(&#39;add&#39;, &#123;  num: 100&#125;); &#x2F;&#x2F; 传递额外参数
4.2 Mutation需要遵循Vue的响应规则在开发中向state增加额外数据时，需要遵循Vue的响应规则

最好提前在你的 store 中初始化好所有所需属性

当需要在对象上添加新属性时，你应该使用 Vue.set(obj, ‘newProp’, 123), 或者以新对象替换老对象。例如，利用 ES6的对象展开运算符
12345addNewState(state, payload) &#123; &#x2F;&#x2F; 我打算再这儿添加新的属性到state  &#x2F;&#x2F; Vue.set(state, &#39;newProp&#39;, &#39;添加一个新值！&#39;); &#x2F;&#x2F; 这是一种写法  &#x2F;&#x2F; 这种写法用新对象替换老对象  this.replaceState(&#123;...state, newProp: &#39;添加一个新值！&#39;&#125;)&#125;
4.3 Mutation里必须是同步操作下面这种操作必须避免
1234567mutations: &#123;  someMutation (state) &#123;    api.callAsyncMethod(() &#x3D;&gt; &#123;      &#x2F;&#x2F;.....    &#125;)  &#125;&#125;
4.4 mapMutations同前
1234567891011121314import &#123;mapMutations&#125; from &#39;vuex&#39;;export default &#123;  methods: &#123;    ...mapMutations([      &#39;increment&#39;, &#x2F;&#x2F; 将 &#96;this.increment()&#96; 映射为 &#96;this.$store.commit(&#39;increment&#39;)&#96;      &#x2F;&#x2F; &#96;mapMutations&#96; 也支持载荷：      &#39;incrementBy&#39; &#x2F;&#x2F; 将 &#96;this.incrementBy(amount)&#96; 映射为 &#96;this.$store.commit(&#39;incrementBy&#39;, amount)&#96;    ]),    ...mapMutations(&#123;      add: &#39;increment&#39; &#x2F;&#x2F; 将 &#96;this.add()&#96; 映射为 &#96;this.$store.commit(&#39;increment&#39;)&#96;    &#125;)  &#125;&#125;
5. Actionaction与mutation类似，不同点在于

action用于提交mutation

action支持任意的异步操作，之前提到mutation只支持同步操作，所以将异步操作放在action里执行，然后再调用mutation中的方法来改变state中的状态首先在state中定义一个状态
123state: &#123;  product: &#39;car&#39;&#125;
接着在mutation中定义一个方法
123changeProduct(state, payload) &#123;  state.product &#x3D; payload.change;&#125;
然后在action中定义一个方法
123456789101112131415actions: &#123;  changeProduct(&#123;commit&#125;, payload) &#123; &#x2F;&#x2F; 这个context是一个与 store 实例具有相同方法和属性的对象    &#x2F;&#x2F; 调用mutation里的changeProduct方法    &#x2F;&#x2F; commit(&#39;changeProduct&#39;, &#123;change: &#39;ship&#39;&#125;);    &#x2F;&#x2F; 改成异步方式    &#x2F;&#x2F; setTimeout(() &#x3D;&gt; &#123;    &#x2F;&#x2F;   commit(&#39;changeProduct&#39;, &#123;change: &#39;ship&#39;&#125;);    &#x2F;&#x2F; &#125;, 1500)    &#x2F;&#x2F; 使用载荷    let temp &#x3D; &#39;ship+&#39; + payload.extraInfo;     setTimeout(() &#x3D;&gt; &#123;      commit(&#39;changeProduct&#39;, &#123;change: temp&#125;);    &#125;, 1500)  &#125;&#125;
最后在methods中定义事件触发
1234567891011121314methods: &#123;  selectProduct() &#123;    &#x2F;&#x2F; this.$store.dispatch(&#39;changeProduct&#39;)    &#x2F;&#x2F; 载荷方式分发    &#x2F;&#x2F; this.$store.dispatch(&#39;changeProduct&#39;, &#123;    &#x2F;&#x2F;   extraInfo: &#39;sportcar&#39;    &#x2F;&#x2F; &#125;)    &#x2F;&#x2F; 或者这种    this.$store.dispatch(&#123;      type: &#39;changeProduct&#39;,      extraInfo: &#39;-&gt;sportcar&#39;    &#125;)  &#125;&#125;
5.1 mapActions具体用法同前，不做具体说明
123456789101112131415import &#123;mapActions&#125; from &#39;vuex&#39;;export default &#123;  &#x2F;&#x2F; ...  methods: &#123;    ...mapActions([      &#39;increment&#39;, &#x2F;&#x2F; 将 &#96;this.increment()&#96; 映射为 &#96;this.$store.dispatch(&#39;increment&#39;)&#96;      &#x2F;&#x2F; &#96;mapActions&#96; 也支持载荷：      &#39;incrementBy&#39; &#x2F;&#x2F; 将 &#96;this.incrementBy(amount)&#96; 映射为 &#96;this.$store.dispatch(&#39;incrementBy&#39;, amount)&#96;    ]),    ...mapActions(&#123;      add: &#39;increment&#39; &#x2F;&#x2F; 将 &#96;this.add()&#96; 映射为 &#96;this.$store.dispatch(&#39;increment&#39;)&#96;    &#125;)  &#125;&#125;
有时候我们想获取action里面异步执行后的状态然后再去修改其他信息，这个可以借助Promise来实现。这里在state里面声明一个状态
123456state: &#123;  userInfo: &#123; &#x2F;&#x2F; 这个变量用来测试组合变量    name: &#39;lee&#39;,    age: 23  &#125;&#125;
复制代码接着声明mutation
123456mutations: &#123;    &#x2F;&#x2F; 以下用来测试组合action    changeInfo(state, payload) &#123;      state.userInfo.name &#x3D; &#39;lee haha&#39;;    &#125;&#125;
复制代码声明action
12345678910actions: &#123;  changeInfo(context, payload) &#123;    return new Promise((resolve, reject) &#x3D;&gt; &#123;      setTimeout(() &#x3D;&gt; &#123;        context.commit(&#39;changeInfo&#39;);        resolve();      &#125;, 2000)    &#125;)  &#125;&#125;
复制代码这时我们在组件里面定义方法去派发这个action
123456789101112data() &#123;  return &#123;    status: &#39;信息还没修改！&#39;  &#125;&#125;methods: &#123;  modifyInfo() &#123;    this.$store.dispatch(&#39;changeInfo&#39;).then(() &#x3D;&gt; &#123;      this.status &#x3D; &#39;信息修改成功&#39;;    &#125;);  &#125;&#125;



                        
                    </p>
                </a>
            </div>

            
        </article>
    

    
        <article class="box post post-item">
            <div class="post-title"><a href="/2020/10/22/Vue-Router%E5%9F%BA%E7%A1%80/">Vue-Router基础</a></div>
            <div class="post-meta">
                
                <i class="fa fa-calendar"></i> <time>2020-10-22</time>
                <span class="dotted">|</span>
                <i class="fa fa-user"></i> 
            </div>

            <div class="post-excerpt">
                <a href="/2020/10/22/Vue-Router%E5%9F%BA%E7%A1%80/">
                    <p>
                        
                            什么是路由？
路由(routing)就是通过互联的网络把信息从源地址传输到目的地址的过程
路由是根据不同的ulr地址展示不同的内容或页面后端路由在早起开发时整个HTML页面是由服务端来渲染的，后端直接将渲染好的HTML页面响应给客户端
浏览器在地址栏中输入不同的URL时，每次都向后端发起请求，后端再响应请求
在后台拼接出不同的HTML页面返回给前端显示
意味着浏览器会刷新页面，如果网速不好的话，页面会全空白再显示出内容，后端路由有一个极大的问题就是前后端不分离前端路由
随着AJAX的出现，有了前后端分离
后端通过API来返回数据，前端通过AJAX来请求数据，然后用JS将数据渲染到页面上
这样的模式使得，前后端任务分工明确，后端注重数据处理，前端注重交互和数据可视化
并且移动端（Android、IOS）出现后，可使用同一套API，无需做任何处理SPA
SPA（single page web application）,译为单页Web应用
简单说 SPA 就是一个 web 项目只有一个 html 页面, 一旦页面加载完成, SPA 不会因为用户的操作进行页面的重新加载或跳转
取而代之的是利用 JS 动态的变换 html 的内容, 从而模拟多个视图间跳转前端路由的核心改变URL，但是页面不进行整体的刷新q前端路由的规则url的hash模式也就是锚点（#），本质上是改变window.location的href属性

2.我们可以直接赋值location.hash改变href但是页面不发生刷新
1234location.href&#x2F;&#x2F;  &quot;http:&#x2F;&#x2F;localhost:8080&quot;location.hash &#x3D; &quot;&#x2F;home&quot;&#x2F;&#x2F;  &quot;&#x2F;home&quot;
HTML5的history模式history模式是HTML5新增的, 它有五种模式改变URL而不刷新页面
1.history.pushState()可回退
123456history.pushState(&#123;&#125;, &#39;&#39;, &#39;foo&#39;)&#x2F;&#x2F;  undefinedhistory.pushState(&#123;&#125;, &#39;&#39;, &#39;test&#39;)&#x2F;&#x2F;  undefinedhistory.pushState(&#123;&#125;, &#39;&#39;, &#39;a&#39;)&#x2F;&#x2F;  undefined
2.history.replaceState()替换URL，不可回退
1234history.replaceState(&#123;&#125;, &#39;&#39;, &#39;&#x2F;foo&#39;)&#x2F;&#x2F;  undefinedhistory.replaceState(&#123;&#125;, &#39;&#39;, &#39;&#x2F;test&#39;)&#x2F;&#x2F;  undefined
3.history.back()回退到上一次的URL
4.history.forward()前进到上一次的URL
5.history.go(Number)前往指定URL
12history.go(2)&#x2F;&#x2F;  undefined
Vue-Router基础vue-router是Vue.js官方的路由插件, 它和vue.js是深度继承的, 用于构建单页面应用vue-router是基于路由和组件的
路由用于设定访问路径, 将路径和组件映射起来在vue-router的单页面应用中, 页面的路径的改变就是组件的切换

步骤一：npm安装1npm install vue-router --save
步骤二：在项目中引用它

导入路由对象, 并且调用Vue.use(VueRouter)安装路由功能
创建路由实例, 并传入路由映射配置
在主入口文件: 引入创建的路由实例, Vue实例中挂载路由实例
1234567891011121314151617181920212223242526272829303132333435router&#x2F;index.jsimport VueRouter from &#39;vue-router&#39;import Vue from &#39;vue&#39;import Home from &#39;..&#x2F;components&#x2F;Home.vue&#39;import About from &#39;..&#x2F;components&#x2F;About.vue&#39;Vue.use(VueRouter)const routes &#x3D; [  &#123;    path: &#39;.&#x2F;home&#39;,    components: Home  &#125;,  &#123;    path: &#39;.&#x2F;about&#39;,    components: About  &#125;]const router &#x3D; new VueRouter(&#123;  routes&#125;)export default router.&#x2F;math.jsimport Vue from &#39;vue&#39;import App from &#39;.&#x2F;App.vue&#39;import router from &#39;.&#x2F;router&#39;new Vue(&#123;  render: h &#x3D;&gt; h(App),  router&#125;).$(&#39;#app&#39;)

步骤三：使用vue-router

12345678&#x2F;&#x2F;使用路由&lt;router-link to&#x3D;&quot;&#x2F;path&quot;&gt;和 &lt;router-view&gt;&lt;template&gt;  &lt;div&gt;    &lt;router-link to&#x3D;&quot;&#x2F;home&quot;&gt;首页&lt;&#x2F;router-link&gt;    &lt;router-link to&#x3D;&quot;&#x2F;about&quot;&gt;关闭&lt;&#x2F;router-link&gt;    &lt;router-view&gt;&lt;&#x2F;router-view&gt;  &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;
路由组件详解
router-link 该标签是已经内置全局的组件, 它会被渲染成一个a标签

to=”path”: 该属性会被渲染为href属性to=”path”: 属性的值会渲染为 # 开头的 hash 地址

path: 在路由中配置的 path 路径

router-view 该标签会根据当前的路径, 动态渲染出相对应的组件在路由切换时, 切换的是router-view挂载的组件, 其他内容不会发生改变
路由配置其他补充1.路由默认路径进入网站首页, 希望router-view渲染首页的内容


在路由规则中添加默认路径的重定向
12345678const routes &#x3D; [    &#123;      &#x2F;&#x2F; 配置默认路径      path: &#39;&#x2F;&#39;,      &#x2F;&#x2F; 重定向到&#x2F;home路径      redirect: &#39;&#x2F;home&#39;    &#125;]
2.路径的History模式页面显示的URL, 不希望是哈希值带 #/home, 希望显示正常的URL: /home
12345&#x2F;&#x2F; 创建VueRouter对象const router &#x3D; new VueRouter(&#123;  routes,&#x2F;&#x2F; 路由规则  mode: &#39;history&#39;&#x2F;&#x2F; URL显示的模式&#125;)
3.router-link和配置路由的属性补充route-link其他的属性

tag=””: tab可以指定router-link组件渲染成什么元素
replace: 没有回退history记录, 前进没有效果
active class=””: 当router-link对应的路径匹配成功时, 会自动给当前元素添加一个router-link-active的class, 设置active-class可以更改默认的名称

4.编程式导航没有使用router-link全局组件, 来跳转URL

this.$router.push(‘path’): 来实现跳转URL, 有回退history记录
this.$router.replace(‘path’): 来实现跳转URL, 没有回退history记录12345678910methods: &#123;        home() &#123;            &#x2F;&#x2F; 没有使用&lt;router-link&gt;全局组件,来跳转URL,如何实现            &#x2F;&#x2F; this.$router.push(&#39;&#x2F;home&#39;) &#x2F;&#x2F; 有回退记录            this.$router.replace(&#39;&#x2F;home&#39;) &#x2F;&#x2F; 没有回退记录      &#125;,        about() &#123;            &#x2F;&#x2F; this.$router.push(&#39;&#x2F;about&#39;)            this.$router.replace(&#39;&#x2F;about&#39;)       &#125;&#125;
路由传参一般路由有两种传参方式，分为 params 和 queryparams这个 params 是和 name 配合使用的。跳转过去之后路径不会带上参数。12router.push(&#123; name: &#39;user&#39;, params: &#123; userId: &#39;123&#39; &#125;&#125;) &#x2F;&#x2F;参数传递this.$route.params.id  &#x2F;&#x2F;参数接收
query这个 query 是和 path 配合使用的，跳转过去之后路径会带上参数变成 /search?id=1 般使用在查询方面。12router.push(&#123; path: &#39;search&#39;, query: &#123; id: &#39;1&#39; &#125;&#125;)  &#x2F;&#x2F;参数传递this.$route.query.id  &#x2F;&#x2F;参数接收
路由守卫当路由进行需要进行导航的时候，我们可以通过路由守卫的方式，来进行路由的跳转和和取消跳转。

路由守卫有三种，一种是全局的守卫，一种是路由的守卫，一种是组件的守卫。
全局守卫全局守卫一般用来验证是否已经登陆。如果登陆，就进行，没有登录就跳转到登录页面。
1234567891011router.beforeEach((to, from, next) &#x3D;&gt; &#123;  next()&#125;)router.beforeResolve((to, from, next) &#x3D;&gt; &#123;  next()&#125;)router.afterEach((to, from) &#x3D;&gt; &#123;  &#x2F;* 这是全局后置钩子，不会接受 next 函数，也不改变导航*&#x2F;&#125;)
路由独享守卫跟全局路由一样，只不过是针对单个路由，来进行设置。
123456789routes: [    &#123;      path: &#39;&#x2F;foo&#39;,      component: Foo,      beforeEnter: (to, from, next) &#x3D;&gt; &#123;        &#x2F;&#x2F; ...      &#125;    &#125;  ]
组件守卫组件的守卫，一共有三个
123456789101112131415beforeRouteEnter (to, from, next) &#123;  &#x2F;&#x2F; 在渲染该组件的对应路由被 confirm 前调用  &#x2F;&#x2F; 不！能！获取组件实例 &#96;this&#96;  &#x2F;&#x2F; 因为当守卫执行前，组件实例还没被创建&#125;,beforeRouteUpdate (to, from, next) &#123;  &#x2F;&#x2F; 在当前路由改变，但是该组件被复用时调用  &#x2F;&#x2F; 举例来说，对于一个带有动态参数的路径 &#x2F;foo&#x2F;:id，在 &#x2F;foo&#x2F;1 和 &#x2F;foo&#x2F;2 之间跳转的时候，  &#x2F;&#x2F; 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。  &#x2F;&#x2F; 可以访问组件实例 &#96;this&#96;&#125;,beforeRouteLeave (to, from, next) &#123;  &#x2F;&#x2F; 导航离开该组件的对应路由时调用  &#x2F;&#x2F; 可以访问组件实例 &#96;this&#96;&#125;




                        
                    </p>
                </a>
            </div>

            
        </article>
    

    
        <article class="box post post-item">
            <div class="post-title"><a href="/2020/10/19/js%E5%A4%A7%E9%87%8F%E6%95%B0%E6%8D%AE%E8%AE%A1%E7%AE%97%E5%AF%BC%E8%87%B4%E9%A1%B5%E9%9D%A2%E5%81%87%E6%AD%BB%EF%BC%88Web%20Worker%EF%BC%89/">js大量数据计算导致页面假死（Web Worker）</a></div>
            <div class="post-meta">
                
                <i class="fa fa-calendar"></i> <time>2020-10-19</time>
                <span class="dotted">|</span>
                <i class="fa fa-user"></i> 
            </div>

            <div class="post-excerpt">
                <a href="/2020/10/19/js%E5%A4%A7%E9%87%8F%E6%95%B0%E6%8D%AE%E8%AE%A1%E7%AE%97%E5%AF%BC%E8%87%B4%E9%A1%B5%E9%9D%A2%E5%81%87%E6%AD%BB%EF%BC%88Web%20Worker%EF%BC%89/">
                    <p>
                        
                            js为什么页面会卡顿呢，以60Hz为例，即一秒钟的动画就是由60张静态图片连在一起。60fps是动画播放比较理想、比较基础的要求，windows系统有个刷新频率也是这个意思。60fps就要求一帧的时间为1s/60=16.67ms。浏览器显示页面的时候，要处理js逻辑，还要做渲染，每个执行片段的时间不能超过16.67ms。实际上，浏览器内核自身支撑体系运行也需要消耗一些时间，所以留给我们的时间差不多只有10ms。并且在处理js计算时，浏览器不会响应用户的操作，所以就造成了页面“假死”。
Web Worker什么是Web WorkerWeb Work，就是为JavaScript创造多线程环境，允许主线程创建Web Worker线程，将一些任务分配给后台运行。在主线程运行的同事，Work线程在后台运行，两者互不干扰。等到Work线程完成计算任务再把结果返回给主线程。这样的好处是，一些密集或者高延迟的计算任务，被Work线程给分担了，这样主线程就会很流程。Worker线程一旦创建成功，就会始终运行，不会被主线程上的活动打断取消。这样有利于随时响应主线程的通信。但是，这也造成了Worker比较耗费资源，不应该过度使用，所以一旦使用完毕，就应该关闭。
注意点：1.同源限制：分配给Worker线程运行的脚本文件，必须与主线程的脚本文件同源。2.DOM限制：Work线程所在的全局对象和主线程不一样，所以无法读取主线程所在网页的DOM对象，也无法使用document，window，parent这些对象。但是可以使用navigator和location。3.通信联系：Worker线程和主线程不在同一个上下文环境，他们不能直接通信，必须通过消息完成。4.脚本限制：Worker线程不能执行alert和confirm方法，但是可以使用XMLHttpRequest对象发出的AJAX请求。5.文件限制：Work线程不能读取本地文件，它所加载的脚本必须来自网络。
用法
创建1var worker &#x3D; new Worker(“work.js”)
主线程通过postMessage向Work线程发送消息123&#x2F;&#x2F;postMessage()参数就是传送的数据，支持各种数据类型worker.postMessage(&#39;Hello World&#39;); worker.postMessage(&#123;method: &#39;echo&#39;, args: [&#39;Work&#39;]&#125;);
主线程通过onmessage()指定监听函数，接收子线程发回来的消息123worker.onmessage &#x3D; function (event) &#123;  console.log(&#39;Received message &#39; + event.data);&#125;
主线程关闭Work线程

1worker.terminate();

Worker 线程内部需要有一个监听函数，监听message事件。

12345678910111213self.addEventListener(&#39;message&#39;, function (e) &#123;  self.postMessage(&#39;You said: &#39; + e.data);&#125;, false);&#x2F;&#x2F;上面代码中，self代表子线程自身，即子线程的全局对象。因此，等同于下面两种写法&#x2F;&#x2F; 写法一this.addEventListener(&#39;message&#39;, function (e) &#123;  this.postMessage(&#39;You said: &#39; + e.data);&#125;, false);&#x2F;&#x2F; 写法二addEventListener(&#39;message&#39;, function (e) &#123;  postMessage(&#39;You said: &#39; + e.data);&#125;, false);

Work线程内部关闭1self.close();


                        
                    </p>
                </a>
            </div>

            
        </article>
    

    
        <article class="box post post-item">
            <div class="post-title"><a href="/2020/10/19/%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BA%E6%9C%AC%E5%8D%9A%E5%AE%A2/">如何搭建本博客</a></div>
            <div class="post-meta">
                
                <i class="fa fa-calendar"></i> <time>2020-10-19</time>
                <span class="dotted">|</span>
                <i class="fa fa-user"></i> 
            </div>

            <div class="post-excerpt">
                <a href="/2020/10/19/%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BA%E6%9C%AC%E5%8D%9A%E5%AE%A2/">
                    <p>
                        
                            什么是HexoHexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。优点！！！不需要服务器可以直接部署在你的GitHub上##安装###1.安装GitWindows: git官网 下载后会有一个Git Bash命令行工具Linux：
1sudo apt-get install git
2.安装Node.js Hexo是基于Node.js编写，所以需要安装一下Node.js和里面的npm包管理工具Windows：Node.js官网选择LTS版本Linux：
12sudo apt-get install nodejssudo apt-get install npm
安装完成后打开命令行检查一下是否安装成功
12node -vnpm -v
3.安装Hexo安装完Git和Node.js就可以来安装Hexo了，可以先在桌面创建一个blog文件夹，然后在命令行中cd到该目录下，在命令行中键入命令
1npm install -g hexo-cli
老规矩Hexo -v看一下版本号到此就安装完成了接下来我们初始化一下我们的Hexo
123hexo init blogcd blognpm install
我们来看看项目结构node_modules: 依赖包public：存放生成的页面scaffolds：生成文章的一些模板source：用来存放你的文章themes：主题_config.yml: 博客的配置文件运行服务，走你
1hexo server
在浏览器输入localhost:4000就可以看到你生成的博客了可以用ctrl+c将服务关掉
4.GitHub上创建个人仓库首先你得有一个GitHub账号如果没有的话的就注册一个吧GitHub官网注册完成后点击New repository新建一个仓库仓库名称必须为你的用户名.github.io只有这样以将你博客部署到GitHub的时候才会被识别假设我的用户名是kumiko77那我的仓库名就是kumiko77.github.io点击create repository创建完成
5.生成SSH添加到GitHub打开你的GitBash
1ssh-keygen -t rsa -b 4096 -C &quot;你的GitHub邮箱&quot;
然后一路回车 ，此时他会告诉你SSH文件已经生成了在GitHub的setting中，找到SSH keys的设置选项，点击New SSH key把你的id_rsa.pub里面的信息复制进去然后在GitBash中查看是否成功
1ssh -T git@github.com
6.将Hexo部署到GitHun上到这一步就可以讲我们的博客和Hexo关联起来了打开我们的配置文件_config.yml翻到最下面将内容修改为
1234deploy:  type: git  repo: https:&#x2F;&#x2F;github.com&#x2F;用户名&#x2F;用户名.github.io.git  branch: master
然后我们先安装deploy-git ，也就是部署的命令,这样你才能用命令部署到GitHub
1npm install hexo-deployer-git --save
接着我们
123hexo cleanhexo generatehexo deploy
可以使用缩写
12hexo generate &#x3D;&gt; hexo ghexo deploy &#x3D;&gt; hexo d
hexo deploy之后可能会要你输入GitHub的用户名和密码成功之后就可以在http://用户名.github.io看到你的博客了

                        
                    </p>
                </a>
            </div>

            
        </article>
    

    
        <article class="box post post-item">
            <div class="post-title"><a href="/2020/10/19/ES6%EF%BC%9Aasync%20await/">ES6：async await</a></div>
            <div class="post-meta">
                
                <i class="fa fa-calendar"></i> <time>2020-10-19</time>
                <span class="dotted">|</span>
                <i class="fa fa-user"></i> 
            </div>

            <div class="post-excerpt">
                <a href="/2020/10/19/ES6%EF%BC%9Aasync%20await/">
                    <p>
                        
                            ES6：async/await在ES6中我们可以使用Generator来控制执行流程
12345function* foo(x) &#123;    yield x + 1;    yield x + 2;    return x + 3;&#125;
我们可以不断调用Generator对象的next()方法来控制函数的流程，但是这样好像不是特别的语义化。所以终于在ES7中有来Generator函数的语法糖async函数，用关键字Async来表示，其函数内部用await来表示异步操作该函数有效的解决来JavaScript中的异步操作问题。
相较于 Generator，Async函数的优点在于：Generator 函数的执行必须依靠执行器，而 Async（） 函数自带执行器，调用方式跟普通函数的调用一样。Async 和 await相较于 * 和 yield 更加语义化。async 函数返回值是 Promise 对象，比 Generator函数返回的 Iterator 对象方便，可以直接使用 then（）方法进行调用。
12345678910111213141516171819&#x2F;&#x2F;未使用async&#x2F;awaitfn &#x3D; () &#x3D;&gt; &#123;  return new Promise((resolve, reject) &#x3D;&gt; &#123;    setTimeout(() &#x3D;&gt; &#123;      resolve(1)    &#125;, 2000)  &#125;)&#125;const Fn &#x3D; () &#x3D;&gt;&#123;  fn().then((res) &#x3D;&gt; &#123;    console.log(res)  &#125;)&#125;Fn()console.log(2)&#x2F;&#x2F;输出&#x2F;&#x2F;先打印2&#x2F;&#x2F;两秒后打印1
12345678910111213141516171819&#x2F;&#x2F;使用async&#x2F;awaitfn &#x3D; () &#x3D;&gt; &#123;  return new Promise((resolve, reject) &#x3D;&gt; &#123;    setTimeout(() &#x3D;&gt; &#123;      resolve(1)    &#125;, 2000)  &#125;)&#125;const Fn &#x3D; async () &#x3D;&gt; &#123;  await fn().then((res) &#x3D;&gt; &#123;    console.log(res)  &#125;)  console.log(2)&#125;Fn()&#x2F;&#x2F;输出&#x2F;&#x2F;过两秒输出1&#x2F;&#x2F;2
async的字面意思是异步，其用于定义一个异步函数，返回的是一个Promise对象。await的意思是等待，Promise是一个承诺，其承诺的是无论成功与否都会将返回值传递到then()的回调函数中，await也是一个承诺，其承诺的是不管怎样我都会等待你的操作执行完成在执行下一步操作。上述代码运行了async/await的作用就是等待fn()执行完成之后，在执行之后的操作
例子在写JS循环时，JS提供了许多好用数组api接口，forEach就是其中一个，但是碰上了async/await，可能就悲剧了，得到了不是你想要的结果
123456789101112131415161718function getUserInfo (id) &#123;  return new Promise(resolve &#x3D;&gt; &#123;    setTimeout(() &#x3D;&gt; &#123;      resolve(&#123;        id: id,        name: &#39;xxx&#39;,        age: &#39;xxx&#39;      &#125;)    &#125;, 200)  &#125;)&#125;const users &#x3D; [&#123;id: 1&#125;, &#123;id: 2&#125;, &#123;id: 3&#125;]let userInfos &#x3D; []users.forEach(async user &#x3D;&gt; &#123;  let info &#x3D; await getUserInfo(user.id)  userInfos.push(info)&#125;)console.log(userInfos) &#x2F;&#x2F; []
上面这段代码是不是很熟悉，模拟获取多个用户的用户信息，然后得到一个用户信息数组，但是很遗憾，上面的userInfos得到的是一个空数组，上面这段代码加上了async/await后，forEach循环就变成了异步的，因此不会等到所有用户信息都请求完才打印userInfos，想要等待结果的返回再打印，还是要回到老式的for循环，来看代码：
123456789101112131415161718192021function getUserInfo (id) &#123;  return new Promise(resolve &#x3D;&gt; &#123;    setTimeout(() &#x3D;&gt; &#123;      resolve(&#123;        id: id,        name: &#39;xxx&#39;,        age: &#39;xxx&#39;      &#125;)    &#125;, 200)  &#125;)&#125;const users &#x3D; [&#123;id: 1&#125;, &#123;id: 2&#125;, &#123;id: 3&#125;]let userInfos &#x3D; []async function call() &#123;  for (user of users) &#123;    let info &#x3D; await getUserInfo(user.id)    userInfos.push(info)  &#125;  console.log(userInfos)&#125;call()
上面这种写法是继发式的，也就是会等前面一个任务执行完，再执行下一个，但是也许你并不关心执行过程，只要拿到想要的结果就行了，这时并发式的效率会更高，来看代码：
123456789101112131415161718function getUserInfo (id) &#123;  return new Promise(resolve &#x3D;&gt; &#123;    setTimeout(() &#x3D;&gt; &#123;      resolve(&#123;        id: id,        name: &#39;xxx&#39;,        age: &#39;xxx&#39;      &#125;)    &#125;, 200)  &#125;)&#125;const users &#x3D; [&#123;id: 1&#125;, &#123;id: 2&#125;, &#123;id: 3&#125;]let userInfos &#x3D; []const promises &#x3D; users.map(user &#x3D;&gt; getUserInfo(user.id))Promise.all(promises).then(res &#x3D;&gt; &#123;  userInfos &#x3D; res  console.log(userInfos)&#125;)

                        
                    </p>
                </a>
            </div>

            
        </article>
    

    
        <article class="box post post-item">
            <div class="post-title"><a href="/2020/10/15/Promise/">Promise</a></div>
            <div class="post-meta">
                
                <i class="fa fa-calendar"></i> <time>2020-10-15</time>
                <span class="dotted">|</span>
                <i class="fa fa-user"></i> 
            </div>

            <div class="post-excerpt">
                <a href="/2020/10/15/Promise/">
                    <p>
                        
                            PromisePromise 是异步编程的一种解决方案，比传统的解决方案回调函数和事件更合理和更强大。有了Promise对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数
同步与异步总所周知JavaScript的运行环境是“单线程”。所谓单线程，就是指JS引擎中负责执行JavaScript代码的线程只有一个。也就是说一次只能完成一个任务，要先等这个任务完成了之后才能执行下一个任务，并且它会“阻塞”其他任务，这个任务称之为“主线程”
同步如上所说，同步模式一次只能执行一个任务，如果这个任务没执行完，下一个任务就无法执行，如果这个任务执行时间过长，就会造成“线程阻塞”
12while(true);console.log(&#39;hello&#39;);
这就是一个例子，while是一个死循环，所以之后的操作永远不会执行
异步异步模式与同步模式相反，可以多个任务一起执行，函数调用后不会立即返回执行结果，如果任务A需要等待，会先继续执行任务B，等任务A执行完了在继续执行回调
1234567setTimeout(function() &#123;    console.log(&#39;taskA&#39;);&#125;, 0);console.log(&#39;taskB&#39;);输出：&#x2F;&#x2F;taskB&#x2F;&#x2F;taskA
定时器的延时为0，但taskA还是晚于taskB输出。这是为什么呢？由于定时器是异步的，异步任务会在当前脚本的所有同步任务执行完才会执行
为什么要使用PromisePromise用于处理异步操作，既然我们可以用过回调来解决异步操作，为什么要还要使用Promise呢？上代码
12345678910111213function sendRequest(url, param) &#123;    return new Promise(function (resolve, reject) &#123;        request(url, param, resolve, reject);    &#125;);&#125;sendRequest(&#39;test&#39;, &#39;&#39;).then(function(data) &#123;    &#x2F;&#x2F;异步操作成功后的回调    console.log(&#39;请求成功, 这是返回的数据:&#39;, data);&#125;, function(error) &#123;    &#x2F;&#x2F;异步操作失败后的回调    console.log(&#39;sorry, 请求失败了, 这是失败信息:&#39;, error);&#125;);
这么一看，并没有什么区别，还比直接使用回调复杂，得先声明Promise再定义其回调。其实，Promise的真正强大之处在于它的多重链式调用，可以避免层层嵌套回调。如果我们在第一次ajax请求后，还要用它返回的结果再次请求呢？
12345678910111213141516request(&#39;test1.html&#39;, &#39;&#39;, function(data1) &#123;    console.log(&#39;第一次请求成功, 这是返回的数据:&#39;, data1);    request(&#39;test2.html&#39;, data1, function (data2) &#123;        console.log(&#39;第二次请求成功, 这是返回的数据:&#39;, data2);        request(&#39;test3.html&#39;, data2, function (data3) &#123;            console.log(&#39;第三次请求成功, 这是返回的数据:&#39;, data3);            &#x2F;&#x2F;request... 继续请求        &#125;, function(error3) &#123;            console.log(&#39;第三次请求失败, 这是失败信息:&#39;, error3);        &#125;);    &#125;, function(error2) &#123;        console.log(&#39;第二次请求失败, 这是失败信息:&#39;, error2);    &#125;);&#125;, function(error1) &#123;    console.log(&#39;第一次请求失败, 这是失败信息:&#39;, error1);&#125;);
多层回调，头皮发麻，体验十分难受，后期代码也很难维护，但是如果使用Promise我们就可以使用then来进行“链式回调”，将异步的操作以同步操作的流程展示出来
123456789101112sendRequest(&#39;test1.html&#39;, &#39;&#39;).then(data1 &#x3D;&gt; &#123;    console.log(&#39;第一次请求成功, 这是返回的数据:&#39;, data1);    return sendRequest(&#39;test2.html&#39;, data1);&#125;).then(data2 &#x3D;&gt; &#123;    console.log(&#39;第二次请求成功, 这是返回的数据:&#39;, data2);    return sendRequest(&#39;test3.html&#39;, data2);&#125;).then(data3 &#x3D;&gt; &#123;    console.log(&#39;第三次请求成功, 这是返回的数据:&#39;, data3);&#125;).catch(error &#x3D;&gt; &#123;    &#x2F;&#x2F;用catch捕捉前面的错误    console.log(&#39;sorry, 请求失败了, 这是失败信息:&#39;, error);&#125;);
这段代码看起来就比上面的清晰来很多
Promise的基本用法首先说说Promise的3种状态

pending：初始值
fulfilled：代表操作成功
rejected：代表操作失败Promise有两种改变状态的方式，既可以从pending变成fulfilled，也可以从pending变成rejected，状态一旦改变，就会一直保持这个状态，不能在变成另一个状态，状态发生改变时就会执行Promise.then()

缺点1.Promise一旦声明，就会立即执行，无法取消
2.如果不设置回调函数，就无法把错误反映到外部
声明一个promise12345678var promise &#x3D; new Promise(function (resolve, reject) &#123;    if (&#x2F;* 操作成功 *&#x2F;) &#123;        resolve(data);    &#125; else &#123;        &#x2F;* 操作失败 *&#x2F;        reject(error);    &#125;&#125;);
Promise通过new来声明，并接受一个function作为参数，该函数携带两个参数，分别是resolve和reject

resolve：在异步操作成功时调用，并将异步操作的结果作为参数传递出去
reject：在异步操作失败时调用，并将异步操作的执行错误作为参数传递出去12345promise.then(function(data) &#123;  &#x2F;&#x2F; do something when success&#125;, function(error) &#123;  &#x2F;&#x2F; do something when failure&#125;);
Promise.then()会返回一个Promise对象。携带两个参数，第一个参数为状态从pending变成fulfilled时执行，第二个参数为状态从pending变成rejceted时执行，第一个参数必须有，第二个参数可有可无基本API.then()1Promise.then(onFulfilled, onRejected)
在Promise状态发生改变时才会被调用.catch()该方法等同于.then(‘’, onRejected)的别名，用于指定发生错误时的回调函数1234567891011promise.then(function(data) &#123;    console.log(&#39;success&#39;);&#125;).catch(function(error) &#123;    console.log(&#39;error&#39;, error);&#125;);promise.then(function(data) &#123;    console.log(&#39;success&#39;);&#125;).then(undefined, function(error) &#123;    console.log(&#39;error&#39;, error);&#125;);
reject方法等同于抛出一个错误123456789101112var promise &#x3D; new Promise(function (resolve, reject) &#123;    throw new Error(&#39;test&#39;);&#125;);&#x2F;*******等同于*******&#x2F;var promise &#x3D; new Promise(function (resolve, reject) &#123;    reject(new Error(&#39;test&#39;));&#125;);&#x2F;&#x2F;用catch捕获promise.catch(function (error) &#123;    console.log(error);&#125;);
但是Promise的状态一旦发生改成就不会在变化了，即状态一旦变成fulfilled，再抛出错误也不会变成rejcet，所以也就不会被catch捕获到

如果没有catch那Promise的错误就不会被传到外界，这就是Promise的缺点之一
.all()该方法接受一个数组，数组里均为Promise对象，将数组里的所有promise变成一个Promise对象，该对象的状态由数组里Promise对象的状态决定

当数组里所有Promise对象的状态都变成fulfilled时这个新Promise对象的状态才会变成fulfilled
当数组里有一个Promise对象的状态变成rejected时这个新Promise对象的状态就会变成rejected，并将数组里第一个Promise的reject的返回值传递给新Promise对象的回调函数123456789101112131415var p1 &#x3D; new Promise(function (resolve, reject) &#123;    setTimeout(resolve, 3000, &quot;first&quot;);&#125;);var p2 &#x3D; new Promise(function (resolve, reject) &#123;    resolve(&#39;second&#39;);&#125;);var p3 &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123;  setTimeout(resolve, 1000, &quot;third&quot;);&#125;); Promise.all([p1, p2, p3]).then(function(values) &#123;   console.log(values); &#125;);约三秒后输出[&quot;first&quot;, &quot;second&quot;, &quot;third&quot;]
1234567891011121314151617var p1 &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123;   setTimeout(resolve, 1000, &quot;one&quot;); &#125;); var p2 &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123;   setTimeout(reject, 2000, &quot;two&quot;); &#125;);var p3 &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123;  reject(&quot;three&quot;);&#125;);Promise.all([p1, p2, p3]).then(function (value) &#123;    console.log(&#39;resolve&#39;, value);&#125;, function (error) &#123;    console.log(&#39;reject&#39;, error);    &#x2F;&#x2F; &#x3D;&gt; reject three&#125;);输出 reject three
.race()使用方法同.all(),不同的是使用.race()生成的新Promise对象的状态值会随着数组里Promise对象的状态改变而改变，并将第一个执行完毕的Promise对象的结果返回1234567891011121314var p1 &#x3D; new Promise(function(resolve, reject) &#123;     setTimeout(reject, 500, &quot;one&quot;); &#125;);var p2 &#x3D; new Promise(function(resolve, reject) &#123;     setTimeout(resolve, 100, &quot;two&quot;); &#125;);Promise.race([p1, p2]).then(function(value) &#123;    console.log(&#39;resolve&#39;, value); &#125;, function(error) &#123;    console.log(&#39;reject&#39;, error); &#125;);输出 resolve two
在第一个Promise对象被resolve之后并不会影响后边的操作1234567891011121314151617181920var fastPromise &#x3D; new Promise(function (resolve) &#123;    setTimeout(function () &#123;        console.log(&#39;fastPromise&#39;);        resolve(&#39;resolve fastPromise&#39;);    &#125;, 100);&#125;);var slowPromise &#x3D; new Promise(function (resolve) &#123;    setTimeout(function () &#123;        console.log(&#39;slowPromise&#39;);        resolve(&#39;resolve slowPromise&#39;);    &#125;, 1000);&#125;);&#x2F;&#x2F; 第一个promise变为resolve后程序停止Promise.race([fastPromise, slowPromise]).then(function (value) &#123;    console.log(value);    &#x2F;&#x2F; &#x3D;&gt; resolve fastPromise&#125;);输出fastPromiseresolve fastPromiseslowPromise     &#x2F;&#x2F;仍会执行
.resolve()123Promise.resolve(value);Promise.resolve(promise);Promise.resolve(thenable);
它可以看做new Promise()的快捷方式123456Promise.resolve(&#39;Success&#39;);&#x2F;*******等同于*******&#x2F;new Promise(function (resolve) &#123;    resolve(&#39;Success&#39;);&#125;);
这段代码会让这个Promise对象立即进入resolved状态，并将结果success传递给then指定的onFulfilled回调函数1234Promise.resolve(&#39;success&#39;).then(function (value) &#123;    console.log(value);&#125;);输出 Success
Promise.resolve()的另一个作用就是将thenable对象（即带有then方法的对象）转换为promise对象。

123456789101112var p1 &#x3D; Promise.resolve(&#123;     then: function (resolve, reject) &#123;         resolve(&quot;this is an thenable object!&quot;);    &#125;&#125;);console.log(p1 instanceof Promise);     &#x2F;&#x2F; &#x3D;&gt; truep1.then(function(value) &#123;    console.log(value);     &#x2F;&#x2F; &#x3D;&gt; this is an thenable object!  &#125;, function(e) &#123;    &#x2F;&#x2F;not called&#125;);
.reject()同.resolve()

                        
                    </p>
                </a>
            </div>

            
        </article>
    

    
        <article class="box post post-item">
            <div class="post-title"><a href="/2020/10/12/%E9%98%B2%E6%8A%96%E4%B8%8E%E8%8A%82%E6%B5%81/">防抖与节流</a></div>
            <div class="post-meta">
                
                <i class="fa fa-calendar"></i> <time>2020-10-12</time>
                <span class="dotted">|</span>
                <i class="fa fa-user"></i> 
            </div>

            <div class="post-excerpt">
                <a href="/2020/10/12/%E9%98%B2%E6%8A%96%E4%B8%8E%E8%8A%82%E6%B5%81/">
                    <p>
                        
                            防抖函数和节流函数是在日常开发中使用频率比较高的两个函数，可以有效的优化浏览器性能
防抖函数(debounce)在事件被触发 n 秒后再执行回调，如果在这 n 秒内又被触发，则重新计时
例子1如果有人进电梯（触发事件），那电梯将在 10 秒钟后启动（执行事件），这时如果又有人进电梯了（在 10 秒内再次触发该事件），我们又得等 10 秒再启动（重新计时）
例子2** 滚动条监听 ** ，对于这么一个常用的功能来说，很多网站都会提供一个返回顶部的按钮。这个按钮只会在滚动到距离顶部一定位置之后才出现，假设说我们现在有这么一个需求，监听浏览器滚动事件，返回当前滚条与顶部的距离
12345function showTop  () &#123;    var scrollTop &#x3D; document.body.scrollTop || document.documentElement.scrollTop;　　console.log(&#39;滚动条位置：&#39; + scrollTop);&#125;window.onscroll  &#x3D; showTop
但是这样写代码，在运行的时候会发现存在一个问题：这个函数的默认执行频率，太！高！了！。 高到什么程度呢？以chrome为例，我们可以点击选中一个页面的滚动条，然后点击一次键盘的【向下方向键】，会发现函数执行了8-9次
然而实际上我们并不需要如此高频的反馈，毕竟浏览器的性能是有限的，不应该浪费在这里。所以这里就需要防抖函数来处理
基于上述场景给出一种思路，在第一次触发时不执行该操作，给出一个延迟值比如200ms，接着

如果在200ms内没有再次触发滚动条操作，则执行该操作
如果在200ms内再次触发滚动条操作则清楚计时器重新计时

效果： 在短时间内重复执行相同操作，只执行一次
1234567891011121314function debounce(fn,delay)&#123;    let timer &#x3D; null &#x2F;&#x2F;闭包    return function() &#123;        if(timer)&#123;            clearTimeout(timer)         &#125;        timer &#x3D; setTimeout(fn,delay)    &#125;&#125;function showTop  () &#123;    var scrollTop &#x3D; document.body.scrollTop || document.documentElement.scrollTop;　　console.log(&#39;滚动条位置：&#39; + scrollTop);&#125;window.onscroll &#x3D; debounce(showTop,1000) &#x2F;&#x2F; 为了方便观察效果我们取个大点的间断值，实际使用根据需要来配置
此时会发现，必须在停止滚动1秒以后，才会打印出滚动条位置。
节流函数(throttle)继续说上面的问题，上述场景出现的问题用防抖来解决也会出现一个问题：
如果在限定时间，有个用户闲着无聊一直拖着滚动条移来移去不断触发滚动条时间，理论上是永远不会当前距离顶部的距离
但是万一需求提出就算用户不断拖动滚动条，也能在某个时间间隔给出反馈
对于此需求，我们可以设计一种类似控制阀门一样定期开放的函数，也就是让函数执行一次后，在某个时间段内暂时失效，过了这段时间后再重新激活
效果： 如果短时间内大量触发同一事件，那么在函数执行一次之后，该函数在指定的时间期限内不再工作，直至过了这段时间才重新生效。
1234567891011121314151617181920function throttle(fn,delay)&#123;    let valid &#x3D; true    return function() &#123;       if(!valid)&#123;           &#x2F;&#x2F;休息时间           return false        &#125;       &#x2F;&#x2F; 工作时间，执行函数并且在间隔期内把状态位设为无效        valid &#x3D; false        setTimeout(() &#x3D;&gt; &#123;            fn()            valid &#x3D; true;        &#125;, delay)    &#125;&#125;function showTop  () &#123;    var scrollTop &#x3D; document.body.scrollTop || document.documentElement.scrollTop;　　console.log(&#39;滚动条位置：&#39; + scrollTop);&#125;window.onscroll &#x3D; throttle(showTop,1000)
如果一直拖着滚动条进行滚动，那么会以1s的时间间隔，持续输出当前位置和顶部的距离
应用场景节流1.搜索框input事件，例如要支持输入实时搜索可以使用节流方案（间隔一段时间就必须查询相关内容），或者实现输入间隔大于某个值（如500ms），就当做用户输入完成，然后开始搜索，具体使用哪种方案要看业务需求。

自动保存草稿功能，当用户在输入的时候(一直触发事件),单位时间内只保存一次草稿防抖
表单的连续点击，防止重复提交。比如重复发送一篇文章。

2.类百度的搜索，连续输入等输入停止后再搜索。

                        
                    </p>
                </a>
            </div>

            
        </article>
    

    
        <article class="box post post-item">
            <div class="post-title"><a href="/2020/10/12/ES6%EF%BC%9Avar%20let%20const/">ES6：var let const</a></div>
            <div class="post-meta">
                
                <i class="fa fa-calendar"></i> <time>2020-10-12</time>
                <span class="dotted">|</span>
                <i class="fa fa-user"></i> 
            </div>

            <div class="post-excerpt">
                <a href="/2020/10/12/ES6%EF%BC%9Avar%20let%20const/">
                    <p>
                        
                            
首先声明一点，js中声明之后无法修改的变量称为常量反之可以修改的称为变量
在ES6之前常量与变量的声明都是使用var，例如：123var a &#x3D; 1;a &#x3D; 10;console.log(a);  &#x2F;&#x2F;10
区别let/const 和 var的区别


不可变量提升
块级作用域
不可重复声明
暂存性死区
let、const声明的变量均不会挂在在window对象上

tips:
1:通过const声明的变量必须马上赋值，否则会报错(Missing initializer in const declaration)
2:通过const声明的数据不可更改除了对象、数组（其修改的是内部数据、而不是指针指向地址
不使用块级作用域的弊端
如果使用ES5的var来声明变量，内层变量会覆盖外层变量从而造成全局污染

同第一点，用于循环记数的变量会泄漏为全局变量


123456var time &#x3D; new Date();function tFunc() &#123;  console.log(time);   var time &#x3D; ‘123’;&#125;tFunc();  &#x2F;&#x2F;undefined
12345var arr &#x3D; [1, 2, 3, 4, 5];for(var i &#x3D; 0; i &lt; arr.length; i++)&#123;  console.log(arr[i]);&#125;console.log(i)  &#x2F;&#x2F;5(此处的i全局范围内都可以读取到）
关于块级作用域12345678function func()&#123;  let a &#x3D; 1;  if(true)&#123;    let a &#x3D; 2    console.log(a)  &#x2F;&#x2F;2 内层a  &#125;  console.log(a)  &#x2F;&#x2F;1 外层的a&#125;
1234&#123;  let a &#x3D; &#39;Hello World&#39;&#125;console.log(a); &#x2F;&#x2F; 报错 获取不到子作用域的变量
不可变量提升何为变量提升？在统一作用域下变量可在声明前使用且值为undefined
1234567&#x2F;&#x2F; varconsole.log(a); &#x2F;&#x2F; 输出undefinedvar a &#x3D; 2;	&#x2F;&#x2F; letconsole.log(b); &#x2F;&#x2F; 报错ReferenceErrorlet b &#x3D; 2;
暂存性死区只要块级作用域内存在let命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响
12345var a &#x3D; 123;if (true) &#123;  a &#x3D; &#39;abc&#39;; &#x2F;&#x2F; 报错 因为本区域有tmp声明变量  let a; &#x2F;&#x2F; 绑定if这个块级的作用域 不能出现tmp变量&#125;
不可重复声明变量let、const不允许在相同作用域内，重复声明同一个变量
123456789function func(arg) &#123;  let arg; &#x2F;&#x2F; 报错&#125;function func(arg) &#123;  &#123;    let arg; &#x2F;&#x2F; 不报错  &#125;&#125;
let、const声明的全局变量不会挂载在顶层对象下面1.浏览器环境顶层对象是: window
2.var声明的全局变量会挂在顶层对象下面，而let、const不会挂在顶层对象下面。
1234var a &#x3D; 1;window.a &#x2F;&#x2F; 1let b &#x3D; 1;window.b &#x2F;&#x2F; undefined
                        
                    </p>
                </a>
            </div>

            
        </article>
    



            </div>
            <div class="aside">
    
        <div class="box widget">
    <div class="introduction">
        <p><img src="/images/avatar.jpg" alt="head-sculpture" /></p>
        <p class="name">
            博落回
        </p>
        <p class="slogan">流连矣 忘景幻云催 峦栈醺醺说旧梦 重山迟迟映霞辉 向晚共邀归 —— 忆江南</p>
    </div>
</div>
    
        
<div class="box widget">
    <div class="title">Recent</div>
    <ul class="item-box">
        
            
                <li><a href="/2020/11/07/%E5%85%B3%E4%BA%8EVue%E4%B8%AD%E7%9A%84%E8%99%9A%E6%8B%9FDOM/">关于Vue中的虚拟DOM</a></li>
            
        
            
                <li><a href="/2020/11/07/%E5%85%B3%E4%BA%8EVue%E7%9A%84%E6%95%B0%E6%8D%AE%E5%93%8D%E5%BA%94%E5%BC%8F/">关于Vue的数据响应式</a></li>
            
        
            
                <li><a href="/2020/10/28/%E5%85%B3%E4%BA%8Ejs%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE/">关于js原型和原型链</a></li>
            
        
            
                <li><a href="/2020/10/26/Vuex%E6%A8%A1%E5%9D%97%E5%8C%96/">Vuex模块化</a></li>
            
        
            
                <li><a href="/2020/10/26/Vuex%E5%9F%BA%E7%A1%80/">Vuex基础</a></li>
            
        
            
                <li><a href="/2020/10/22/Vue-Router%E5%9F%BA%E7%A1%80/">Vue-Router基础</a></li>
            
        
            
                <li><a href="/2020/10/19/js%E5%A4%A7%E9%87%8F%E6%95%B0%E6%8D%AE%E8%AE%A1%E7%AE%97%E5%AF%BC%E8%87%B4%E9%A1%B5%E9%9D%A2%E5%81%87%E6%AD%BB%EF%BC%88Web%20Worker%EF%BC%89/">js大量数据计算导致页面假死（Web Worker）</a></li>
            
        
            
                <li><a href="/2020/10/19/%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BA%E6%9C%AC%E5%8D%9A%E5%AE%A2/">如何搭建本博客</a></li>
            
        
    </ul>
</div>

    
        
    
        
  <div class="box widget">
    <div class="title">Archives</div>
    <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">2020-11</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">2020-10</a><span class="archive-list-count">10</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">2020-06</a><span class="archive-list-count">2</span></li></ul>
  </div>

    
        
    
</div>
        </section>
        <footer class="footer">
    <div class="global-width footer-box">
        <div class="copyright">
            <span>Copyright &copy; 2019</span>
            <span class="dotted">|</span>
            <span>Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a></span>
            <span class="dotted">|</span>
            <span>Theme by <a href="javascript:">Loren</a></span>
            <span class="dotted">|</span>
            <span><a href="http://www.beian.miit.gov.cn" target="_blank" rel="noopener">浙ICP备18016660号-1</a></span>
        </div>
    </div>
</footer>
    </div>

<script>
    hljs.initHighlightingOnLoad();
</script>
</body>
</html>