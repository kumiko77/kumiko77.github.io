<!DOCTYPE html>
<html lang="en">
<head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
<meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">




    <meta name="keywords" content=""/>



    <meta name="description" content="Kumiko77"/>


<meta name="Robots" content="all">


    <title>Kumiko77</title>


<link rel="icon" href="/images/favicon.ico">

<link rel="stylesheet" href="/css/font-awesome.min.css">


<link rel="stylesheet" href="/css/atom-one-dark.css">


<link rel="stylesheet" href="/css/style.css">


<script src="/js/highlight.min.js"></script>

<meta name="generator" content="Hexo 4.2.1"></head>
<body>
    <div class="main-container">
        <header class="header">
    <div class="global-width">
        <nav class="nav-box">
            
                <a class="nav-item" href="/"
                
                >Home</a>
            
                <a class="nav-item" href="/resume"
                
                >Resume</a>
            
                <a class="nav-item" href="/mood"
                
                   target="_blank"
                
                >Mood</a>
            
                <a class="nav-item" href="/amusement/tetris"
                
                   target="_blank"
                
                >Amusement</a>
            
                <a class="nav-item" href="/about"
                
                >About</a>
            
        </nav>
    </div>
</header>

        <section class="content global-width">
            <div class="main">
                
    
        <article class="box post post-item">
            <div class="post-title"><a href="/2020/10/19/%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BA%E6%9C%AC%E5%8D%9A%E5%AE%A2/">如何搭建本博客</a></div>
            <div class="post-meta">
                
                <i class="fa fa-calendar"></i> <time>2020-10-19</time>
                <span class="dotted">|</span>
                <i class="fa fa-user"></i> 
            </div>

            <div class="post-excerpt">
                <a href="/2020/10/19/%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BA%E6%9C%AC%E5%8D%9A%E5%AE%A2/">
                    <p>
                        
                            什么是HexoHexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。优点！！！不需要服务器可以直接部署在你的GitHub上##安装###1.安装GitWindows: git官网 下载后会有一个Git Bash命令行工具Linux：
1sudo apt-get install git
2.安装Node.js Hexo是基于Node.js编写，所以需要安装一下Node.js和里面的npm包管理工具Windows：Node.js官网选择LTS版本Linux：
12sudo apt-get install nodejssudo apt-get install npm
安装完成后打开命令行检查一下是否安装成功
12node -vnpm -v
3.安装Hexo安装完Git和Node.js就可以来安装Hexo了，可以先在桌面创建一个blog文件夹，然后在命令行中cd到该目录下，在命令行中键入命令
1npm install -g hexo-cli
老规矩Hexo -v看一下版本号到此就安装完成了接下来我们初始化一下我们的Hexo
123hexo init blogcd blognpm install
我们来看看项目结构node_modules: 依赖包public：存放生成的页面scaffolds：生成文章的一些模板source：用来存放你的文章themes：主题_config.yml: 博客的配置文件运行服务，走你
1hexo server
在浏览器输入localhost:4000就可以看到你生成的博客了可以用ctrl+c将服务关掉
4.GitHub上创建个人仓库首先你得有一个GitHub账号如果没有的话的就注册一个吧GitHub官网注册完成后点击New repository新建一个仓库仓库名称必须为你的用户名.github.io只有这样以将你博客部署到GitHub的时候才会被识别假设我的用户名是kumiko77那我的仓库名就是kumiko77.github.io点击create repository创建完成
5.生成SSH添加到GitHub打开你的GitBash
1ssh-keygen -t rsa -b 4096 -C &quot;你的GitHub邮箱&quot;
然后一路回车 ，此时他会告诉你SSH文件已经生成了在GitHub的setting中，找到SSH keys的设置选项，点击New SSH key把你的id_rsa.pub里面的信息复制进去然后在GitBash中查看是否成功
1ssh -T git@github.com
6.将Hexo部署到GitHun上到这一步就可以讲我们的博客和Hexo关联起来了打开我们的配置文件_config.yml翻到最下面将内容修改为
1234deploy:  type: git  repo: https:&#x2F;&#x2F;github.com&#x2F;用户名&#x2F;用户名.github.io.git  branch: master
然后我们先安装deploy-git ，也就是部署的命令,这样你才能用命令部署到GitHub
1npm install hexo-deployer-git --save
接着我们
123hexo cleanhexo generatehexo deploy
可以使用缩写
12hexo generate &#x3D;&gt; hexo ghexo deploy &#x3D;&gt; hexo d
hexo deploy之后可能会要你输入GitHub的用户名和密码成功之后就可以在http://用户名.github.io看到你的博客了

                        
                    </p>
                </a>
            </div>

            
        </article>
    

    
        <article class="box post post-item">
            <div class="post-title"><a href="/2020/10/19/ES6%EF%BC%9Aasync%20await/">ES6：async await</a></div>
            <div class="post-meta">
                
                <i class="fa fa-calendar"></i> <time>2020-10-19</time>
                <span class="dotted">|</span>
                <i class="fa fa-user"></i> 
            </div>

            <div class="post-excerpt">
                <a href="/2020/10/19/ES6%EF%BC%9Aasync%20await/">
                    <p>
                        
                            ES6：async/await在ES6中我们可以使用Generator来控制执行流程
12345function* foo(x) &#123;    yield x + 1;    yield x + 2;    return x + 3;&#125;
我们可以不断调用Generator对象的next()方法来控制函数的流程，但是这样好像不是特别的语义化。所以终于在ES7中有来Generator函数的语法糖async函数，用关键字Async来表示，其函数内部用await来表示异步操作该函数有效的解决来JavaScript中的异步操作问题。
相较于 Generator，Async函数的优点在于：Generator 函数的执行必须依靠执行器，而 Async（） 函数自带执行器，调用方式跟普通函数的调用一样。Async 和 await相较于 * 和 yield 更加语义化。async 函数返回值是 Promise 对象，比 Generator函数返回的 Iterator 对象方便，可以直接使用 then（）方法进行调用。
12345678910111213141516171819&#x2F;&#x2F;未使用async&#x2F;awaitfn &#x3D; () &#x3D;&gt; &#123;  return new Promise((resolve, reject) &#x3D;&gt; &#123;    setTimeout(() &#x3D;&gt; &#123;      resolve(1)    &#125;, 2000)  &#125;)&#125;const Fn &#x3D; () &#x3D;&gt;&#123;  fn().then((res) &#x3D;&gt; &#123;    console.log(res)  &#125;)&#125;Fn()console.log(2)&#x2F;&#x2F;输出&#x2F;&#x2F;先打印2&#x2F;&#x2F;两秒后打印1
12345678910111213141516171819&#x2F;&#x2F;使用async&#x2F;awaitfn &#x3D; () &#x3D;&gt; &#123;  return new Promise((resolve, reject) &#x3D;&gt; &#123;    setTimeout(() &#x3D;&gt; &#123;      resolve(1)    &#125;, 2000)  &#125;)&#125;const Fn &#x3D; async () &#x3D;&gt; &#123;  await fn().then((res) &#x3D;&gt; &#123;    console.log(res)  &#125;)  console.log(2)&#125;Fn()&#x2F;&#x2F;输出&#x2F;&#x2F;过两秒输出1&#x2F;&#x2F;2
async的字面意思是异步，其用于定义一个异步函数，返回的是一个Promise对象。await的意思是等待，Promise是一个承诺，其承诺的是无论成功与否都会将返回值传递到then()的回调函数中，await也是一个承诺，其承诺的是不管怎样我都会等待你的操作执行完成在执行下一步操作。上述代码运行了async/await的作用就是等待fn()执行完成之后，在执行之后的操作
例子在写JS循环时，JS提供了许多好用数组api接口，forEach就是其中一个，但是碰上了async/await，可能就悲剧了，得到了不是你想要的结果
123456789101112131415161718function getUserInfo (id) &#123;  return new Promise(resolve &#x3D;&gt; &#123;    setTimeout(() &#x3D;&gt; &#123;      resolve(&#123;        id: id,        name: &#39;xxx&#39;,        age: &#39;xxx&#39;      &#125;)    &#125;, 200)  &#125;)&#125;const users &#x3D; [&#123;id: 1&#125;, &#123;id: 2&#125;, &#123;id: 3&#125;]let userInfos &#x3D; []users.forEach(async user &#x3D;&gt; &#123;  let info &#x3D; await getUserInfo(user.id)  userInfos.push(info)&#125;)console.log(userInfos) &#x2F;&#x2F; []
上面这段代码是不是很熟悉，模拟获取多个用户的用户信息，然后得到一个用户信息数组，但是很遗憾，上面的userInfos得到的是一个空数组，上面这段代码加上了async/await后，forEach循环就变成了异步的，因此不会等到所有用户信息都请求完才打印userInfos，想要等待结果的返回再打印，还是要回到老式的for循环，来看代码：
123456789101112131415161718192021function getUserInfo (id) &#123;  return new Promise(resolve &#x3D;&gt; &#123;    setTimeout(() &#x3D;&gt; &#123;      resolve(&#123;        id: id,        name: &#39;xxx&#39;,        age: &#39;xxx&#39;      &#125;)    &#125;, 200)  &#125;)&#125;const users &#x3D; [&#123;id: 1&#125;, &#123;id: 2&#125;, &#123;id: 3&#125;]let userInfos &#x3D; []async function call() &#123;  for (user of users) &#123;    let info &#x3D; await getUserInfo(user.id)    userInfos.push(info)  &#125;  console.log(userInfos)&#125;call()
上面这种写法是继发式的，也就是会等前面一个任务执行完，再执行下一个，但是也许你并不关心执行过程，只要拿到想要的结果就行了，这时并发式的效率会更高，来看代码：
123456789101112131415161718function getUserInfo (id) &#123;  return new Promise(resolve &#x3D;&gt; &#123;    setTimeout(() &#x3D;&gt; &#123;      resolve(&#123;        id: id,        name: &#39;xxx&#39;,        age: &#39;xxx&#39;      &#125;)    &#125;, 200)  &#125;)&#125;const users &#x3D; [&#123;id: 1&#125;, &#123;id: 2&#125;, &#123;id: 3&#125;]let userInfos &#x3D; []const promises &#x3D; users.map(user &#x3D;&gt; getUserInfo(user.id))Promise.all(promises).then(res &#x3D;&gt; &#123;  userInfos &#x3D; res  console.log(userInfos)&#125;)

                        
                    </p>
                </a>
            </div>

            
        </article>
    

    
        <article class="box post post-item">
            <div class="post-title"><a href="/2020/10/15/Promise/">Promise</a></div>
            <div class="post-meta">
                
                <i class="fa fa-calendar"></i> <time>2020-10-15</time>
                <span class="dotted">|</span>
                <i class="fa fa-user"></i> 
            </div>

            <div class="post-excerpt">
                <a href="/2020/10/15/Promise/">
                    <p>
                        
                            PromisePromise 是异步编程的一种解决方案，比传统的解决方案回调函数和事件更合理和更强大。有了Promise对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数
同步与异步总所周知JavaScript的运行环境是“单线程”。所谓单线程，就是指JS引擎中负责执行JavaScript代码的线程只有一个。也就是说一次只能完成一个任务，要先等这个任务完成了之后才能执行下一个任务，并且它会“阻塞”其他任务，这个任务称之为“主线程”
同步如上所说，同步模式一次只能执行一个任务，如果这个任务没执行完，下一个任务就无法执行，如果这个任务执行时间过长，就会造成“线程阻塞”
12while(true);console.log(&#39;hello&#39;);
这就是一个例子，while是一个死循环，所以之后的操作永远不会执行
异步异步模式与同步模式相反，可以多个任务一起执行，函数调用后不会立即返回执行结果，如果任务A需要等待，会先继续执行任务B，等任务A执行完了在继续执行回调
1234567setTimeout(function() &#123;    console.log(&#39;taskA&#39;);&#125;, 0);console.log(&#39;taskB&#39;);输出：&#x2F;&#x2F;taskB&#x2F;&#x2F;taskA
定时器的延时为0，但taskA还是晚于taskB输出。这是为什么呢？由于定时器是异步的，异步任务会在当前脚本的所有同步任务执行完才会执行
为什么要使用PromisePromise用于处理异步操作，既然我们可以用过回调来解决异步操作，为什么要还要使用Promise呢？上代码
12345678910111213function sendRequest(url, param) &#123;    return new Promise(function (resolve, reject) &#123;        request(url, param, resolve, reject);    &#125;);&#125;sendRequest(&#39;test&#39;, &#39;&#39;).then(function(data) &#123;    &#x2F;&#x2F;异步操作成功后的回调    console.log(&#39;请求成功, 这是返回的数据:&#39;, data);&#125;, function(error) &#123;    &#x2F;&#x2F;异步操作失败后的回调    console.log(&#39;sorry, 请求失败了, 这是失败信息:&#39;, error);&#125;);
这么一看，并没有什么区别，还比直接使用回调复杂，得先声明Promise再定义其回调。其实，Promise的真正强大之处在于它的多重链式调用，可以避免层层嵌套回调。如果我们在第一次ajax请求后，还要用它返回的结果再次请求呢？
12345678910111213141516request(&#39;test1.html&#39;, &#39;&#39;, function(data1) &#123;    console.log(&#39;第一次请求成功, 这是返回的数据:&#39;, data1);    request(&#39;test2.html&#39;, data1, function (data2) &#123;        console.log(&#39;第二次请求成功, 这是返回的数据:&#39;, data2);        request(&#39;test3.html&#39;, data2, function (data3) &#123;            console.log(&#39;第三次请求成功, 这是返回的数据:&#39;, data3);            &#x2F;&#x2F;request... 继续请求        &#125;, function(error3) &#123;            console.log(&#39;第三次请求失败, 这是失败信息:&#39;, error3);        &#125;);    &#125;, function(error2) &#123;        console.log(&#39;第二次请求失败, 这是失败信息:&#39;, error2);    &#125;);&#125;, function(error1) &#123;    console.log(&#39;第一次请求失败, 这是失败信息:&#39;, error1);&#125;);
多层回调，头皮发麻，体验十分难受，后期代码也很难维护，但是如果使用Promise我们就可以使用then来进行“链式回调”，将异步的操作以同步操作的流程展示出来
123456789101112sendRequest(&#39;test1.html&#39;, &#39;&#39;).then(data1 &#x3D;&gt; &#123;    console.log(&#39;第一次请求成功, 这是返回的数据:&#39;, data1);    return sendRequest(&#39;test2.html&#39;, data1);&#125;).then(data2 &#x3D;&gt; &#123;    console.log(&#39;第二次请求成功, 这是返回的数据:&#39;, data2);    return sendRequest(&#39;test3.html&#39;, data2);&#125;).then(data3 &#x3D;&gt; &#123;    console.log(&#39;第三次请求成功, 这是返回的数据:&#39;, data3);&#125;).catch(error &#x3D;&gt; &#123;    &#x2F;&#x2F;用catch捕捉前面的错误    console.log(&#39;sorry, 请求失败了, 这是失败信息:&#39;, error);&#125;);
这段代码看起来就比上面的清晰来很多
Promise的基本用法首先说说Promise的3种状态

pending：初始值
fulfilled：代表操作成功
rejected：代表操作失败Promise有两种改变状态的方式，既可以从pending变成fulfilled，也可以从pending变成rejected，状态一旦改变，就会一直保持这个状态，不能在变成另一个状态，状态发生改变时就会执行Promise.then()

缺点1.Promise一旦声明，就会立即执行，无法取消
2.如果不设置回调函数，就无法把错误反映到外部
声明一个promise12345678var promise &#x3D; new Promise(function (resolve, reject) &#123;    if (&#x2F;* 操作成功 *&#x2F;) &#123;        resolve(data);    &#125; else &#123;        &#x2F;* 操作失败 *&#x2F;        reject(error);    &#125;&#125;);
Promise通过new来声明，并接受一个function作为参数，该函数携带两个参数，分别是resolve和reject

resolve：在异步操作成功时调用，并将异步操作的结果作为参数传递出去
reject：在异步操作失败时调用，并将异步操作的执行错误作为参数传递出去12345promise.then(function(data) &#123;  &#x2F;&#x2F; do something when success&#125;, function(error) &#123;  &#x2F;&#x2F; do something when failure&#125;);
Promise.then()会返回一个Promise对象。携带两个参数，第一个参数为状态从pending变成fulfilled时执行，第二个参数为状态从pending变成rejceted时执行，第一个参数必须有，第二个参数可有可无基本API.then()1Promise.then(onFulfilled, onRejected)
在Promise状态发生改变时才会被调用.catch()该方法等同于.then(‘’, onRejected)的别名，用于指定发生错误时的回调函数1234567891011promise.then(function(data) &#123;    console.log(&#39;success&#39;);&#125;).catch(function(error) &#123;    console.log(&#39;error&#39;, error);&#125;);promise.then(function(data) &#123;    console.log(&#39;success&#39;);&#125;).then(undefined, function(error) &#123;    console.log(&#39;error&#39;, error);&#125;);
reject方法等同于抛出一个错误123456789101112var promise &#x3D; new Promise(function (resolve, reject) &#123;    throw new Error(&#39;test&#39;);&#125;);&#x2F;*******等同于*******&#x2F;var promise &#x3D; new Promise(function (resolve, reject) &#123;    reject(new Error(&#39;test&#39;));&#125;);&#x2F;&#x2F;用catch捕获promise.catch(function (error) &#123;    console.log(error);&#125;);
但是Promise的状态一旦发生改成就不会在变化了，即状态一旦变成fulfilled，再抛出错误也不会变成rejcet，所以也就不会被catch捕获到

如果没有catch那Promise的错误就不会被传到外界，这就是Promise的缺点之一
.all()该方法接受一个数组，数组里均为Promise对象，将数组里的所有promise变成一个Promise对象，该对象的状态由数组里Promise对象的状态决定

当数组里所有Promise对象的状态都变成fulfilled时这个新Promise对象的状态才会变成fulfilled
当数组里有一个Promise对象的状态变成rejected时这个新Promise对象的状态就会变成rejected，并将数组里第一个Promise的reject的返回值传递给新Promise对象的回调函数123456789101112131415var p1 &#x3D; new Promise(function (resolve, reject) &#123;    setTimeout(resolve, 3000, &quot;first&quot;);&#125;);var p2 &#x3D; new Promise(function (resolve, reject) &#123;    resolve(&#39;second&#39;);&#125;);var p3 &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123;  setTimeout(resolve, 1000, &quot;third&quot;);&#125;); Promise.all([p1, p2, p3]).then(function(values) &#123;   console.log(values); &#125;);约三秒后输出[&quot;first&quot;, &quot;second&quot;, &quot;third&quot;]
1234567891011121314151617var p1 &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123;   setTimeout(resolve, 1000, &quot;one&quot;); &#125;); var p2 &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123;   setTimeout(reject, 2000, &quot;two&quot;); &#125;);var p3 &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123;  reject(&quot;three&quot;);&#125;);Promise.all([p1, p2, p3]).then(function (value) &#123;    console.log(&#39;resolve&#39;, value);&#125;, function (error) &#123;    console.log(&#39;reject&#39;, error);    &#x2F;&#x2F; &#x3D;&gt; reject three&#125;);输出 reject three
.race()使用方法同.all(),不同的是使用.race()生成的新Promise对象的状态值会随着数组里Promise对象的状态改变而改变，并将第一个执行完毕的Promise对象的结果返回1234567891011121314var p1 &#x3D; new Promise(function(resolve, reject) &#123;     setTimeout(reject, 500, &quot;one&quot;); &#125;);var p2 &#x3D; new Promise(function(resolve, reject) &#123;     setTimeout(resolve, 100, &quot;two&quot;); &#125;);Promise.race([p1, p2]).then(function(value) &#123;    console.log(&#39;resolve&#39;, value); &#125;, function(error) &#123;    console.log(&#39;reject&#39;, error); &#125;);输出 resolve two
在第一个Promise对象被resolve之后并不会影响后边的操作1234567891011121314151617181920var fastPromise &#x3D; new Promise(function (resolve) &#123;    setTimeout(function () &#123;        console.log(&#39;fastPromise&#39;);        resolve(&#39;resolve fastPromise&#39;);    &#125;, 100);&#125;);var slowPromise &#x3D; new Promise(function (resolve) &#123;    setTimeout(function () &#123;        console.log(&#39;slowPromise&#39;);        resolve(&#39;resolve slowPromise&#39;);    &#125;, 1000);&#125;);&#x2F;&#x2F; 第一个promise变为resolve后程序停止Promise.race([fastPromise, slowPromise]).then(function (value) &#123;    console.log(value);    &#x2F;&#x2F; &#x3D;&gt; resolve fastPromise&#125;);输出fastPromiseresolve fastPromiseslowPromise     &#x2F;&#x2F;仍会执行
.resolve()123Promise.resolve(value);Promise.resolve(promise);Promise.resolve(thenable);
它可以看做new Promise()的快捷方式123456Promise.resolve(&#39;Success&#39;);&#x2F;*******等同于*******&#x2F;new Promise(function (resolve) &#123;    resolve(&#39;Success&#39;);&#125;);
这段代码会让这个Promise对象立即进入resolved状态，并将结果success传递给then指定的onFulfilled回调函数1234Promise.resolve(&#39;success&#39;).then(function (value) &#123;    console.log(value);&#125;);输出 Success
Promise.resolve()的另一个作用就是将thenable对象（即带有then方法的对象）转换为promise对象。

123456789101112var p1 &#x3D; Promise.resolve(&#123;     then: function (resolve, reject) &#123;         resolve(&quot;this is an thenable object!&quot;);    &#125;&#125;);console.log(p1 instanceof Promise);     &#x2F;&#x2F; &#x3D;&gt; truep1.then(function(value) &#123;    console.log(value);     &#x2F;&#x2F; &#x3D;&gt; this is an thenable object!  &#125;, function(e) &#123;    &#x2F;&#x2F;not called&#125;);
.reject()同.resolve()

                        
                    </p>
                </a>
            </div>

            
        </article>
    

    
        <article class="box post post-item">
            <div class="post-title"><a href="/2020/10/12/%E9%98%B2%E6%8A%96%E4%B8%8E%E8%8A%82%E6%B5%81/">防抖与节流</a></div>
            <div class="post-meta">
                
                <i class="fa fa-calendar"></i> <time>2020-10-12</time>
                <span class="dotted">|</span>
                <i class="fa fa-user"></i> 
            </div>

            <div class="post-excerpt">
                <a href="/2020/10/12/%E9%98%B2%E6%8A%96%E4%B8%8E%E8%8A%82%E6%B5%81/">
                    <p>
                        
                            防抖函数和节流函数是在日常开发中使用频率比较高的两个函数，可以有效的优化浏览器性能
防抖函数(debounce)在事件被触发 n 秒后再执行回调，如果在这 n 秒内又被触发，则重新计时
例子1如果有人进电梯（触发事件），那电梯将在 10 秒钟后启动（执行事件），这时如果又有人进电梯了（在 10 秒内再次触发该事件），我们又得等 10 秒再启动（重新计时）
例子2** 滚动条监听 ** ，对于这么一个常用的功能来说，很多网站都会提供一个返回顶部的按钮。这个按钮只会在滚动到距离顶部一定位置之后才出现，假设说我们现在有这么一个需求，监听浏览器滚动事件，返回当前滚条与顶部的距离
12345function showTop  () &#123;    var scrollTop &#x3D; document.body.scrollTop || document.documentElement.scrollTop;　　console.log(&#39;滚动条位置：&#39; + scrollTop);&#125;window.onscroll  &#x3D; showTop
但是这样写代码，在运行的时候会发现存在一个问题：这个函数的默认执行频率，太！高！了！。 高到什么程度呢？以chrome为例，我们可以点击选中一个页面的滚动条，然后点击一次键盘的【向下方向键】，会发现函数执行了8-9次
然而实际上我们并不需要如此高频的反馈，毕竟浏览器的性能是有限的，不应该浪费在这里。所以这里就需要防抖函数来处理
基于上述场景给出一种思路，在第一次触发时不执行该操作，给出一个延迟值比如200ms，接着

如果在200ms内没有再次触发滚动条操作，则执行该操作
如果在200ms内再次触发滚动条操作则清楚计时器重新计时

效果： 在短时间内重复执行相同操作，只执行一次
1234567891011121314function debounce(fn,delay)&#123;    let timer &#x3D; null &#x2F;&#x2F;闭包    return function() &#123;        if(timer)&#123;            clearTimeout(timer)         &#125;        timer &#x3D; setTimeout(fn,delay)    &#125;&#125;function showTop  () &#123;    var scrollTop &#x3D; document.body.scrollTop || document.documentElement.scrollTop;　　console.log(&#39;滚动条位置：&#39; + scrollTop);&#125;window.onscroll &#x3D; debounce(showTop,1000) &#x2F;&#x2F; 为了方便观察效果我们取个大点的间断值，实际使用根据需要来配置
此时会发现，必须在停止滚动1秒以后，才会打印出滚动条位置。
节流函数(throttle)继续说上面的问题，上述场景出现的问题用防抖来解决也会出现一个问题：
如果在限定时间，有个用户闲着无聊一直拖着滚动条移来移去不断触发滚动条时间，理论上是永远不会当前距离顶部的距离
但是万一需求提出就算用户不断拖动滚动条，也能在某个时间间隔给出反馈
对于此需求，我们可以设计一种类似控制阀门一样定期开放的函数，也就是让函数执行一次后，在某个时间段内暂时失效，过了这段时间后再重新激活
效果： 如果短时间内大量触发同一事件，那么在函数执行一次之后，该函数在指定的时间期限内不再工作，直至过了这段时间才重新生效。
1234567891011121314151617181920function throttle(fn,delay)&#123;    let valid &#x3D; true    return function() &#123;       if(!valid)&#123;           &#x2F;&#x2F;休息时间           return false        &#125;       &#x2F;&#x2F; 工作时间，执行函数并且在间隔期内把状态位设为无效        valid &#x3D; false        setTimeout(() &#x3D;&gt; &#123;            fn()            valid &#x3D; true;        &#125;, delay)    &#125;&#125;function showTop  () &#123;    var scrollTop &#x3D; document.body.scrollTop || document.documentElement.scrollTop;　　console.log(&#39;滚动条位置：&#39; + scrollTop);&#125;window.onscroll &#x3D; throttle(showTop,1000)
如果一直拖着滚动条进行滚动，那么会以1s的时间间隔，持续输出当前位置和顶部的距离
应用场景节流1.搜索框input事件，例如要支持输入实时搜索可以使用节流方案（间隔一段时间就必须查询相关内容），或者实现输入间隔大于某个值（如500ms），就当做用户输入完成，然后开始搜索，具体使用哪种方案要看业务需求。

自动保存草稿功能，当用户在输入的时候(一直触发事件),单位时间内只保存一次草稿防抖
表单的连续点击，防止重复提交。比如重复发送一篇文章。

2.类百度的搜索，连续输入等输入停止后再搜索。

                        
                    </p>
                </a>
            </div>

            
        </article>
    

    
        <article class="box post post-item">
            <div class="post-title"><a href="/2020/10/12/ES6%EF%BC%9Avar%20let%20const/">ES6：var let const</a></div>
            <div class="post-meta">
                
                <i class="fa fa-calendar"></i> <time>2020-10-12</time>
                <span class="dotted">|</span>
                <i class="fa fa-user"></i> 
            </div>

            <div class="post-excerpt">
                <a href="/2020/10/12/ES6%EF%BC%9Avar%20let%20const/">
                    <p>
                        
                            
首先声明一点，js中声明之后无法修改的变量称为常量反之可以修改的称为变量
在ES6之前常量与变量的声明都是使用var，例如：123var a &#x3D; 1;a &#x3D; 10;console.log(a);  &#x2F;&#x2F;10
区别let/const 和 var的区别


不可变量提升
块级作用域
不可重复声明
暂存性死区
let、const声明的变量均不会挂在在window对象上

tips:
1:通过const声明的变量必须马上赋值，否则会报错(Missing initializer in const declaration)
2:通过const声明的数据不可更改除了对象、数组（其修改的是内部数据、而不是指针指向地址
不使用块级作用域的弊端
如果使用ES5的var来声明变量，内层变量会覆盖外层变量从而造成全局污染

同第一点，用于循环记数的变量会泄漏为全局变量


123456var time &#x3D; new Date();function tFunc() &#123;  console.log(time);   var time &#x3D; ‘123’;&#125;tFunc();  &#x2F;&#x2F;undefined
12345var arr &#x3D; [1, 2, 3, 4, 5];for(var i &#x3D; 0; i &lt; arr.length; i++)&#123;  console.log(arr[i]);&#125;console.log(i)  &#x2F;&#x2F;5(此处的i全局范围内都可以读取到）
关于块级作用域12345678function func()&#123;  let a &#x3D; 1;  if(true)&#123;    let a &#x3D; 2    console.log(a)  &#x2F;&#x2F;2 内层a  &#125;  console.log(a)  &#x2F;&#x2F;1 外层的a&#125;
1234&#123;  let a &#x3D; &#39;Hello World&#39;&#125;console.log(a); &#x2F;&#x2F; 报错 获取不到子作用域的变量
不可变量提升何为变量提升？在统一作用域下变量可在声明前使用且值为undefined
1234567&#x2F;&#x2F; varconsole.log(a); &#x2F;&#x2F; 输出undefinedvar a &#x3D; 2;	&#x2F;&#x2F; letconsole.log(b); &#x2F;&#x2F; 报错ReferenceErrorlet b &#x3D; 2;
暂存性死区只要块级作用域内存在let命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响
12345var a &#x3D; 123;if (true) &#123;  a &#x3D; &#39;abc&#39;; &#x2F;&#x2F; 报错 因为本区域有tmp声明变量  let a; &#x2F;&#x2F; 绑定if这个块级的作用域 不能出现tmp变量&#125;
不可重复声明变量let、const不允许在相同作用域内，重复声明同一个变量
123456789function func(arg) &#123;  let arg; &#x2F;&#x2F; 报错&#125;function func(arg) &#123;  &#123;    let arg; &#x2F;&#x2F; 不报错  &#125;&#125;
let、const声明的全局变量不会挂载在顶层对象下面1.浏览器环境顶层对象是: window
2.var声明的全局变量会挂在顶层对象下面，而let、const不会挂在顶层对象下面。
1234var a &#x3D; 1;window.a &#x2F;&#x2F; 1let b &#x3D; 1;window.b &#x2F;&#x2F; undefined
                        
                    </p>
                </a>
            </div>

            
        </article>
    

    
        <article class="box post post-item">
            <div class="post-title"><a href="/2020/06/18/%E5%85%B3%E4%BA%8E$emit%E7%9A%84%E7%90%86%E8%A7%A3/">关于$emit的理解</a></div>
            <div class="post-meta">
                
                <i class="fa fa-calendar"></i> <time>2020-06-18</time>
                <span class="dotted">|</span>
                <i class="fa fa-user"></i> 
            </div>

            <div class="post-excerpt">
                <a href="/2020/06/18/%E5%85%B3%E4%BA%8E$emit%E7%9A%84%E7%90%86%E8%A7%A3/">
                    <p>
                        
                            $emit
emit的意思是发出、射出。
子组件可以通过props接收父组件传递过来的数据。
子组件也可以用过$emit来触发父组件的自定事件，再说的通俗易懂一些就是子组件可以调用父组件的方法。用法1$emit( eventName, […args] )


eventName：这是一个事件名，会绑定一个方法。当组件触发事件后，将调用这个方法。
[…args]：附加的参数，会被抛出，由上述绑定的方法接收使用。例子子组件：123456789101112131415161718&lt;template&gt;  &lt;button @click="emitEvent"&gt;点击我&lt;/button&gt;&lt;/template&gt;&lt;script&gt;  export default &#123;    data() &#123;      return &#123;        msg: "我是子组件中的数据"      &#125;    &#125;,    methods: &#123;      emitEvent()&#123;        this.$emit('my-event', this.msg)        //通过按钮的点击事件触发方法，然后用$emit触发一个my-event的自定义方法，传递this.msg数据。      &#125;    &#125;  &#125;&lt;/script&gt;
父组件：12345678910111213141516171819&lt;template&gt;  &lt;div id="app"&gt;    &lt;child-a @my-event="getMyEvent"&gt;&lt;/child-a&gt;    &lt;!--父组件中通过监测my-event事件执行一个方法，然后取到子组件中传递过来的值--&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;  import ChildA from './components/child.vue'  export default &#123;    components: &#123;      ChildA    &#125;,    methods: &#123;      getMyEvent(msg)&#123;          console.log('接收的数据---------&gt;'+msg)//接收的数据---------&gt;我是子组件中的数据      &#125;    &#125;  &#125;&lt;/script&gt;


                        
                    </p>
                </a>
            </div>

            
        </article>
    

    
        <article class="box post post-item">
            <div class="post-title"><a href="/2020/06/12/hello-world/">Hello World</a></div>
            <div class="post-meta">
                
                <i class="fa fa-calendar"></i> <time>2020-06-12</time>
                <span class="dotted">|</span>
                <i class="fa fa-user"></i> 
            </div>

            <div class="post-excerpt">
                <a href="/2020/06/12/hello-world/">
                    <p>
                        
                            Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.
Quick StartCreate a new post1$ hexo new "My New Post"

More info: Writing
Run server1$ hexo server

More info: Server
Generate static files1$ hexo generate

More info: Generating
Deploy to remote sites1$ hexo deploy

More info: Deployment

                        
                    </p>
                </a>
            </div>

            
        </article>
    



    <nav class="page-nav">
        <a class="extend prev" rel="prev" href="/archives/">Prev</a><a class="page-number" href="/archives/">1</a><span class="page-number current">2</span>
    </nav>

            </div>
            <div class="aside">
    
        <div class="box widget">
    <div class="introduction">
        <p><img src="/images/avatar.jpg" alt="head-sculpture" /></p>
        <p class="name">
            博落回
        </p>
        <p class="slogan">流连矣 忘景幻云催 峦栈醺醺说旧梦 重山迟迟映霞辉 向晚共邀归 —— 忆江南</p>
    </div>
</div>
    
        
<div class="box widget">
    <div class="title">Recent</div>
    <ul class="item-box">
        
            
                <li><a href="/2020/11/10/%E5%85%B3%E4%BA%8E%E8%B7%A8%E5%9F%9F/">关于跨域</a></li>
            
        
            
                <li><a href="/2020/11/09/%E6%97%A5%E5%B8%B8%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/">日常问题记录</a></li>
            
        
            
                <li><a href="/2020/11/09/reduce%E5%8E%BB%E9%87%8D/">reduce去重</a></li>
            
        
            
                <li><a href="/2020/11/07/%E5%85%B3%E4%BA%8EVue%E4%B8%AD%E7%9A%84%E8%99%9A%E6%8B%9FDOM/">关于Vue中的虚拟DOM</a></li>
            
        
            
                <li><a href="/2020/11/07/%E5%85%B3%E4%BA%8EVue%E7%9A%84%E6%95%B0%E6%8D%AE%E5%93%8D%E5%BA%94%E5%BC%8F/">关于Vue的数据响应式</a></li>
            
        
            
                <li><a href="/2020/10/28/%E5%85%B3%E4%BA%8Ejs%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE/">关于js原型和原型链</a></li>
            
        
            
                <li><a href="/2020/10/26/Vuex%E6%A8%A1%E5%9D%97%E5%8C%96/">Vuex模块化</a></li>
            
        
            
                <li><a href="/2020/10/26/Vuex%E5%9F%BA%E7%A1%80/">Vuex基础</a></li>
            
        
    </ul>
</div>

    
        
    
        
  <div class="box widget">
    <div class="title">Archives</div>
    <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">2020-11</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">2020-10</a><span class="archive-list-count">10</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">2020-06</a><span class="archive-list-count">2</span></li></ul>
  </div>

    
        
    
</div>
        </section>
        <footer class="footer">
    <div class="global-width footer-box">
        <div class="copyright">
            <span>Copyright &copy; 2019</span>
            <span class="dotted">|</span>
            <span>Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a></span>
            <span class="dotted">|</span>
            <span>Theme by <a href="javascript:">Loren</a></span>
            <span class="dotted">|</span>
            <span><a href="http://www.beian.miit.gov.cn" target="_blank" rel="noopener">浙ICP备18016660号-1</a></span>
        </div>
    </div>
</footer>
    </div>

<script>
    hljs.initHighlightingOnLoad();
</script>
</body>
</html>